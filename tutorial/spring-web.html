<html xmlns="http://www.w3.org/1999/html">
<head><title>The Spring Tutorial: Web </title>
    <!-- todo jquery logic to make all class-reference spans links to the javadocs for the code todo jquery logic to make all wikipedia spans links to the wikipedia entry for the text therein. -->
    <style type="text/css"> .todo {
        color: red;
    }

    .wikipedia {
    }

    .diagram {
        width: 500px;
    }

    table, th, td, th {
        vertical-align: top;
    }

    .diagram img {
        width: 500px;
    }

    .caption {
        font-style: italic;
        font-size: smaller;
        display: block;
    }

    code, .git-code, .git-gist, .class-reference {
        font-family: courier, monospace;
        font-size: smaller; /* background-color: #dcdcdc;*/
    } </style>
    <script type="text/javascript" lang="javascript"></script>
    <script src="js/jquery-1.8.3.min.js"></script>
    <script src="js/github-files.js"></script>
    <script src="js/tutorial.js"></script>
</head>
<body><h1>Welcome</h1>

<P> In this tutorial we will show you how to do these things with Spring MVC:</p>
<uL>
    <LI> Create a working web application</LI>
    <LI> Handle form submissions</LI>
    <LI> Build a screen to handle CRUD, (create, read, update, and delete)</LI>
    <LI> Separate UI and Data Model via RESTful Web Services</LI>
    <LI> Learn how to secure your application (sign-in, and sign-out support)</LI>
    <LI> Learn how to secure your REST services with OAuth</LI>
    <LI> Learn how to connect your application to Social Service providers like Facebook</LI>
</uL>
<!-- todo Who is this document for? --> <h2> Who Is This Document For? </h2>

<P> Presumbly you've learned Java, but want to learn about web programming in Java, and you've got a good grasp on the
    core concepts of Spring. For more, please consult the Green Beans blogs and the core Spring tutorial as part of this
    set of tutorials. </P>

<h2> Tools </h2>

<P> Let's build a simple web application to see how the moving parts fit together. Our application will be a simple
    Customer Relationship manager (CRM) of sorts. Users can create an account, login and then manage simple customer
    records. We already have Hibernate-based backend services that manage user (<span module="services" q="tut_web"
                                                                                      class="class-reference">org.springsource.examples.spring31.services.UserService</span>)
    and customer (<span module="services" q="tut_web" class="class-reference">org.springsource.examples.spring31.services.CustomerService</span>)
    data for us.</p>

<P> We're using <A href="http://maven.apache.org">the Apache Maven</A> build tool to include those classes in our web
    application. <SPAN class="todo">To learn more about how to assemble basic service objects with the Spring framework please see our introduction tutorial.</SPAN>
    To learn more about working <A
            href="http://blog.springsource.org/2011/01/17/green-beans-getting-started-with-maven-and-spring/">with
        Apache Maven and Spring, see this blog post</a>. Maven requires a basic directory structure for all modules in a
    given Maven project. The structure looks like this: </p> <span class="git-gist" gist="4947010">https://gist.github.com/joshlong/4947010</span>

<P> Our project has two modules, <CODE>services</CODE> and <CODE>web</CODE>. <CODE>services</CODE> exports a services
    API. The services API is your basic service tier using PostgreSQL and Spring's support for JPA. We won't say much
    more about it beyond that except that it handles manipulating data in terms of the <CODE></CODE></P>

<P> TODO we need to show them how to setup the database and the sample application Check out the data tutorial for
    details on data access with Spring. For a complete step by step introduction opn how to setup the sample application
    please refer to the <CODE>README</CODE>. </P>

<h3> Setting Up the Tool Chain </h3>

<P><SPAN class="todo"> show how to import the code and where to get it and how to use STS File &gt; Import and how Maven helps us. Our tutorial is tool agnostic, but we recommend the free STS edition which comes wiht all sorts nice utilities </SPAN>
</P>

<P> Also: maven has a certain build structure. </P>

<h1> Basic Web Applications with Spring </h1>

<p> The original code in Spring was written to support the web. Indeed, the earliest classes (like, <span
        module="spring-web" q="tut_web"
        class="class-reference">org.springframework.web.context.WebApplicationContext</span>) that Spring founder Rod
    Johnson wrote in his study in England in 2001 were to support Java-based web applications environments. Spring's
    always had a great support for the web. From the beginning, Spring has featured an MVC framework, called Spring MVC.
    Spring MVC at the time looked conceptually very similar to the then entrenched Struts framework. While Spring MVC
    evolved on its own merits, Spring did everything possible to ease the lives of developers using other web
    frameworks, like Struts. The Spring-Struts integration support in the core Spring web modules made Struts a much
    nicer proposition for developers who were stuck using Struts, but wanted a cleaner, POJO-centric component model.
    <!--todo link to what Spring Web Flow is; assume the n00bs don't know -->Indeed, Springs JSF integration for 1.0 and
    2.0, as well as the JSF-centric Spring Web Flow, offer drastically improved user experiences for developers stuck on
    those web frameworks. While Struts is largely a distant memory, and JSF is fast-becoming one, Spring MVC has emerged
    as, and remained, the most popular Java web framework in the world. </p>

<P> There are a lot of reasons for this, but I think it's because Spring MVC has <EM>embraced</EM> the web, not
    attempted to hide developers from it. Indeed, if Spring MVC can be said to <EM>hide</EM> anything, it is the
    complexities of building scalable Servlet-based applications, <EM>not</EM> the web. </P>

<P> Conceptually, web programming is simple: HTTP requests come in, and responses are created and sent in response. No
    state is retained in between requests on either the server or the client, by default. This can be deceptively
    simple. As requests come in, they invariably are handled by some component that acts on them, and is then charged
    with sending a response. A response, in the common case, is some sort of HTML-based page. Unfortunately, there's
    often a disconnect between effective handling of requests (and tying those requests to the appropriate back-end
    business logic) and rendering of nice responses. Put another way, programmers are rarely good user-interface
    designers. So, a separation of the two domains - business logic and server-side handling from designing and
    rendering rich interactive user interfaces - is often necessary. This way, programmers can work on the part that
    matters most to them - the business logic - and the Adobe Dreamweaver-toting designers can focus on the styling and
    design of the user interface. To keep programming applications that behave in this way simpler, programmers have
    adopted a variant of the popular <span class="wikipedia">model-view-controller</span> (MVC) pattern called <span
            id="model2mvc" class="wikipedia">Model_2</span> MVC. This pattern is best visually described like this: </P>

<div class="diagram"><img src="images/model 2 mvc.png"/> <span class="caption"> The Model-2 MVC pattern </span></div>
<P> As HTTP requests come in, they're routed to the <EM>front controller</EM> - the <span module="spring-web"
                                                                                          class="class-reference">org.springframework.web.servlet.DispatcherServlet</span>
    in Spring MVC - which then selects from among the registered <EM>controller</EM> classes and chooses the right one
    to handle the HTTP request. There needs to be some stipulation between the <EM>front controller</EM> and the
    registered controllers as to which controller should handle which request. When the controller is activated, it is
    given access to all the data about the request and it can react accordingly. Once the request is handled, the
    controller must somehow signal that a response should be rendered. Typically, this means telling the framework which
    <EM>view</EM>, or <EM>response</EM>, to render. A view might be a designer-provided template that merges data into
    itself and then renders as HTML. The response might also be something constructed in code in the controller, like
    file data or the binary data for a PDF or spreadsheet. </P>

<h2> Configuring a Servlet 3.0 Container for our Application</h2>

<p> Working with Spring MVC is <EM>very</EM> straightforward! If you're using a Servlet 3.0 container like the market
    and segment-leading <A href="http://tomcat.apache.org">Apache Tomcat 7</A>, then it's even easier! Our initial Java
    web application consists of three classes - <span module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer</span>,
    <span module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.config.WebMvcConfiguration</span>,
    and <span module="web" q="tut_web"
              class="class-reference">org.springsource.examples.spring31.web.ViewController</span> - and several
    artifacts to generate the HTML views. Let's look at these classes. </p>

<P> <!-- todo rewrite this to reflect --> To work with any web framework, like Spring MVC, you need to install the
    various Servlet components using a deployment descriptor (<code>web.xml</code>) or, alternatively, in Servlet 3
    environments, a Java initializer class. Ours will be a Java Servlet 3.0-compatible web application. Servlet 3.0
    applications run in any web container that supports Servlet 3.0, including Apache Tomcat 7. You can use Spring in
    containers that support earlier versions of the Servlet specification, however some Servlet 3.0-specific
    capabilities - such as Java-based initializer classes and features designed to support asynchronous responses won't
    work in those environments. We'll mention the Servlet 3.0 specific bits as we encounter them. </p>

<P> The Servlet environment provides a few low level class types that can be used in building web applications. Here are
    some of the types of classes that we need to be aware of. </P>
<OL>
    <LI><B>Servlets</B> - objects of type <CODE module="servlets" class="class-reference">javax.servlet.Servlet</code>
        that are given a chance to act on incoming HTTP requests and produce replies. This is the most common type of
        component. <CODE>Servlet</CODE>s are mapped to the URLs that they will respond to by a type of pattern.
    </LI>
    <LI><B>Listener</B> - objects of type <CODE module="servlets" class="class-reference">java.util.EventListener</CODE>
        - typically of a Servlet-speciifc subclass like <CODE module="servlets" class="class-reference">javax.servlet.ServletContextListener</CODE>
        or <CODE module="servlets" class="class-reference">javax.servlet.http.HttpSessionAttributeListener</CODE>. These
        classes are notified of various events in the web application such as the creation of data stored in memory, the
        changes in the Servlet container itself, or changes in one of the Servlets managed by a web application
        container.
    </LI>
    <LI><B>Filters</B> - objects of type <CODE module="servlets" class="class-reference">javax.servlet.Filter</CODE>
        that are given a chance to act on, or possibly change, incoming HTTP requests before they are routed to the
        <CODE module="servlets" class="class-reference">javax.servlet.Servlet</CODE>s to which they've been routed and
        all outbound HTTP replies produced by those <CODE>Servlets</CODE>. This is useful in many scenarios - such as
        processing security on all requests, or handling things like GZip compression.
    </LI>
</OL>
<P> Unfortunately, the Servlet environment itself is devoid of most of the basics that any modern web application will
    need. Fortunately, Spring provides these building blocks, letting you assemble them as you like, and letting you
    focus on the task at hand: the business of your application. Here is our Java-based application initializer which
    installs Spring's Servlet infrastructure classes to support our application. If you're familiar with Java Servlets,
    then you'll recognize this as a Java code-only replacement or substitute for <CODE>web.xml</CODE>, an XML-based
    deployment descriptor. </P>

<div class="walkthrough">
    <div module="web" q="tut_web" extension="java" class="git-code">
        org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer
    </div>
    <div><P> The class implements the Spring interface, <span class="class-reference" module="spring-web">org.springframework.web.WebApplicationInitializer</span>.
        which provides a callback method <CODE>void onStartup(ServletContext servletContext) throws
            ServletException</CODE>. This method is called as the application is started by the application container,
        providing a reference to the current <CODE>ServletContext</CODE> which in turn can be used to programmatically
        construct the various Spring MVC framework components. </P>

        <P> This code does two things. It registers a <CODE module="spring-web" class="class-reference">org.springframework.web.context.ContextLoaderListener</code>
            that in turn instantaites our Spring <CODE class="class-reference" module="spring-context">org.springframework.context.ApplicationContext</CODE>
            implementation (<code class="class-reference" q="tut_web" module="web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</code>)
            and makes it available to the entire application and all the Servlet components we register. </p>

        <P> Next, we register the <code class="class-reference" module="spring-webmvc">org.springframework.web.servlet.DispatcherServlet</code>.
            This is the class that Spring provides to handle all incoming HTTP requests (the aforementioned <EM>front
                controller</EM>), routing them to the correct <EM>controllers</EM> and working with the other parts of
            the framework to handle common use cases for us. The <CODE>DispatcherServlet</CODE> can manage its own
            <CODE>ApplicationContext</CODE> as well as see and work with the <COde>ApplicationContext</COde> instances
            that the <CODE>ContextLoaderListener</CODE> creates. The <CODE>DispatcherServlet</CODE>'s <CODE>ApplicationContext</CODE>
            is said to be <EM>parented</EM> by the <CODE>ContextLoaderListener</CODE> <CODE>ApplicationContext</CODE>.
            You could, for example, register different <CODE>DispatcherServlet</CODE> instances for different parts of
            the application, and they could share beans in the <EM>parent</EM> <CODE>ApplicationContext</CODE> managed
            by the <CODE>ContextLoaderListener</CODE>. </p>

        <P> As we're running in a Servlet 3 environment, and want to take advantage of <EM>asynchronous</EM> Spring MVC
            controllers, this code activates <EM>async</EM> support on all components where appropriate by calling
            <CODE>setAsync(true)</CODE>. Since we want Spring MVC to have control over the entire application, this code
            <EM>maps</EM> all components to <CODE>/*</CODE> where possible. This means that <EM>all</EM> requests will
            be handled by Spring MVC. We can later specialize our routing from within Spring MVC, of course. </P></div>
</div>
<h2> Configuring Spring MVC </h2>

<h3> The Simplest Possible Spring MVC Application </h3>

<P> Once we've told the Servlet environment everything it needs to know (for now), we simply need to turn on Spring MVC
    and tailor it based on our application requirements. To get a working, reasonably configured installation of Spring
    MVC, you simply need to add <CODE module="spring-webmvc" class="class-reference">org.springframework.web.servlet.config.annotation.EnableWebMvc</CODE>
    to a Java configuration class that the previously installed <CODE>ContextLoaderListener</CODE> imports. </p>

<div class="git-gist" gist="4726096"> @Configuration @EnableWebMvc public class WebMvcConfiguration {}</div>
<P> By default, this will activate many things based on conventions and the availability of certain libraries on the
    class path. Some of the things supported out of the box: </P>
<uL>
    <LI> The Spring MVC <CODE class="class-reference"
                              module="spring-context">org.springframework.stereotype.Controller</CODE>-annotation based
        component model is turned on. All Spring beans annotated with this stereotype annotation will automatically be
        processed and exported as HTTP handlers. If your application is running in a Servlet 3 environment, then <EM>asynchronous</EM>
        controllers are supported as well.
    </LI>
    <LI> File upload support through the <A href="http://commons.apache.org/proper/commons-fileupload//">Apache Commons
        FileUpload library </A> (if detected on the class path) or via the Servlet 3 <CODE class="class-reference"
                                                                                           module="servlets">javax.servlet.http.Part</CODE>
        API.
    </LI>
    <LI> REST and JSON and XML marshaling support if the <A href="http://jackson.codehaus.org/"> Jackson JSON-Object
        marshaling library</A> or <A href="http://jaxb.java.net/tutorial/">a JAXB implementation</A> is on the class
        path.
    </LI>
    <LI>Bean and form validation if <A href="http://beanvalidation.org/1.0/spec/">a JSR 303</A> implementation <a
            href="http://www.hibernate.org/subprojects/validator.html">like Hibernate Validator</a> is on the classpath.
    </LI>
</uL>
<p> We can do a lot with this simple setup! There's one thing missing, however. As configured, Spring MVC doesn't render
    views in a useful way and it doesn't know about your controllers. You can use the standard Spring annotation <CODE
            class="class-reference" module="spring-context">org.springframework.context.annotation.ComponentScan</CODE>
    annotation to tell Spring to automatically register your data services (Spring beans that handle our data-access
    logic) and your Spring MVC controllers (beans annotated with the <CODE class="class-reference"
                                                                           module="spring-context">org.springframework.stereotype.Controller</CODE>
    annotation) by scanning all the beans in or below the package, or packages, specified. You can specify these
    packages either as a String or by specifying a class that lives in the package you want to scan. The latter approach
    is more refactor-friendly: if you change the package structure of your code, your tooling will update references to
    classes, but might not necessarily refactor Strings that contain a package path. </p>

<P> As depicted in the diagram above, Spring MVC will <EM>resolve</EM> a <EM>view</EM> based on some heuristic supplied
    by a registered implementation of <span class="class-reference" module="spring-webmvc">org.springframework.web.servlet.ViewResolver</span>.
    Let's install a very basic implementation ( <span class="class-reference" module="spring-webmvc">org.springframework.web.servlet.view.InternalResourceViewResolver</span>)
    that will render local <CODE>.jsp</code> pages. </p>

<div class="git-gist" gist="5067119"> @Bean public InternalResourveViewResolver(){ ... }</div>
<P> With this in place, Spring MVC will take a view String (say, <CODE>"hi"</CODE>) and resolve it to <CODE>WEB-INF/hi.jsp</CODE>,
    which it will then load and send back to the client, rendered with any data communicated through the
    <CODE>Model</code> object. Let's pause, do a sanity check, and take a moment to deploy a Spring MVC controller
    complete with a working view. First, add your <CODE>.jsp</CODE> page (<CODE>WEB-INF/hi.jsp</CODE>): </p>

<DIV class="git-gist" gist="5067085"> some jsp content</DIV>
<p> Now, let's create a simple Spring MVC controller. We'll look at that the composition of the controller later,
    instead preferring to verify that everything's working now. Add the following class: </p>

<div class="git-gist" gist="5067155"> @Controller HelloWorldController</div>
<P> Then simply build this and deploy to your application server.
    <!-- TODO link to the beginning of this tutorial If you're using the Spring Tool Suite, you simply need to deploy the application to Apache Tomcat in your <CODE>Servers</code> panel. -->
    You should be able to bring up the page like this: </P>

<div class="diagram"><IMG src="images/hello-world-controller.png"/> <span class="caption"> Change the <CODE>name</CODE> attribute to whatever you like to change the name printed. If the name query parameter is not present, the code will simply default to printing "World." </span>
</div>
<h2> Building the Screens for Our Application </h2>

<P> While the default configuration gives you a lot out of the box, we will tailor the code a little bit to support our
    application's specific requirements. Most of what we will configure in Spring MVC has to do with customizing how
    Spring MVC renders templates for pages. to understand these use cases better, let's look at the pages and screens we
    know we will need to support. </P>
<TABLE width="600">
    <thead>
    <TR>
        <th> Page</th>
        <th> Preview of Page</th>
        <th> Description</th>
    </TR>
    </thead>
    <tr>
        <td><b> signin</b></td>
        <TD><img width="300" src="images/signin.png"/></TD>
        <td> a page where users can sign in. This should be the home page users are greeted with when they visit the
            application for the first time (under <CODE>/*</CODE>).
        </td>
    </tr>
    <tr>
        <td><b>signup</b></td>
        <TD><img width="300" src="images/signup.png"/></TD>
        <td> users should be able to sign up for a new account and potentially register via FaceBook</td>
    </tr>
    <!-- <tr> <td><b> oops </b></td> <TD><img width="300" src="images/oops.png"/></TD> <td> this is the page to show when ever there is an error in the system. Maybe the user accesses the wrong page and needs to be given a 404, or perhaps the system throws some sort of awful as-yet-uknown error. Handling this gracefully is a mark of polish. </td> </tr>-->
    <tr>
        <td><b> profile </b></td>
        <TD><img width="300" src="images/profile.png"/></TD>
        <td> there needs to be some place where users can update their profile information like their password and other
            features (like a profile photo?).
        </td>
    </tr>
    <tr>
        <td><b>customers </b></td>
        <TD><img width="300" src="images/customers.png"/></TD>
        <td>there should of course be a screen to work with data related to customers.</td>
    </tr>
</TABLE>
<h3> Handling Page Layouts with Apache Tiles </h3>

<P><img src="http://tiles.apache.org/images/powered-by-tiles.png" width="200" style="float:left ; margin-right: 20px;"/>
    Building individual web pages is easy. Simply slap together some HTML and then you're set. Building web applications
    well, on the other hand, is an entirely different thing. Well built web applications are visually consistent, often
    sharing consistent styling and theme and layout cues across all pages in the application. <A
            href="http://tiles.apache.org/">Apache Tiles</a> is a very common templating engine. Apache Tiles lets you
    extract <EM>the things that stay the same from the things that change</EM>, in other words: it lets you define a
    template and then - on a page by page basis - change or override the definition for individual parts (or
    <EM>tile</eM>s) of the template without re-specifying the template over and over. </p>
<!--install tiles in Spring --> <P> To enable Apache Tiles for your application, you simply add the following two <CODE>@Bean</CODE>
    definitions to your <CODE>@Configuration</CODE> class above. (Be sure to remove the existing <span
            class="class-reference" module="spring-webmvc">org.springframework.web.servlet.view.InternalResourceViewResolver</span>)
</P>

<div class="git-gist" gist="5059411"> @Bean UrlBasedViewResolver @Bean TilesConfigurer</div>
<P> Apache Tiles has a lot of moving pieces that need to be installed, but Spring can handle all of this for you with
    the <CODE class="class-reference"
              module="spring-webmvc">org.springframework.web.servlet.view.tiles2.TilesConfigurer</CODE>. Recall that
    Spring MVC delegates to <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.ViewResolver</CODE>
    instances to translate strings like <CODE>home</CODE> to an appropriate view template. The <code
            module="spring-webmvc"
            class="class-reference">org.springframework.web.servlet.view.tiles2.TilesViewResolver</code> resolves the
    appropriate Tiles definitions. </P> <!-- then look at a page --> <P> If you look at the swath of screen shots above,
    it's not hard to identify the common elements in our page layouts. In the diagram below, I've drawn colored boxes
    over the parts of the page that could be expected to change. </P>

<div class="diagram"><IMG src="images/signin-tiles.png"/> <span class="caption"> A typical layout divided into its constituent "tiles" </span>
</div>
<P> The page has a header - the band in yellow, a body - the band in green, and a footer - the band in blue. The header
    and footer might have slightly dynamic behavior based on whether someone is logged in or not, but we can expect that
    they'll always be there, so they can be put in the base template definition - the one shared with <EM>all</EM>
    pages. The only thing that will change on a page-by-page basis is the <code>body</code>. Let's look at the
    definition of the base template in Tiles' configuration format. Apache Tiles expects information about the templates
    to be provided in the form of an XML file, called <CODE>tiles.xml</code>. Apache Tiles supports template
    inheritance. You might specify a base definition to be shared as the basis for other templates like this file
    (<CODE>web/src/main/webapp/WEB-INF/layouts/tiles.xml</CODE>): </P>

<div module="web" q="tut_web" extension="xml" class="git-code"> src/main/webapp/WEB-INF/layouts/tiles.xml</div>
<P> This specifies a <CODE>&lt;definition&gt;</CODE> (named <strong><CODE>page</code></strong>) that in turn specifies a
    template to render (the file <CODE>/WEB-INF/layouts/template.jsp</CODE>). The template has regions that are to be
    substituted for actual content or values at render time. </P>

<div class="git-gist" gist="4948600"> html html [tiles:.. ] ...</div>
<P> I've omitted most of the content from this page including the JavaScript and CSS declarations and left only the
    skeletal structure in the example above. In particular, you'll note that we've specified a <CODE>&lt;tiles:insertAttribute&gt;</CODE>
    tag that will attempt to substitute whatever template or value is provided for the region named <EM>content</EM>. If
    you're looking at the <CODE>template.xml</CODE> declaration above, you may be wondering where we specify which
    content is to be substituted into the <EM>content</EM> region. We specify this in each <CODE>tiles.xml</CODE>
    definition that <EM>extends</EM> this root <CODE>tiles.xml</CODE> for each screen. </P>

<p> With this structure in place, it's easy to iterate on new pages as we only have to concern ourselves with the UI
    elements unique to the page in question. For each page, we need to specify a <CODE>tiles.xml</CODE> file that <EM>extends</EM>
    the base <code>tiles.xml</code>. Let's look at the configuration for the <CODE>tiles.xml</CODE> for our signin page,
    <CODE>src/main/webapp/WEB-INF/views/signin/signin.jsp </CODE>. </p>

<div module="web" q="tut_web" extension="jsp" class="git-code"> src/main/webapp/WEB-INF/views/signin/tiles.xml</div>
<P> This definition (named <strong><code>signin</code></strong>) extends <CODE>page</CODE>, defined above. It specifies
    the content to be placed in the <CODE>content</CODE> tile from the base definition. The structure of our views looks
    like this: </P>

<div class="diagram"><IMG src="images/tiles-hierarchy.png"/> <span class="caption"> The <EM>root</EM> Tiles definition lives in <CODE>WEB-INF/layouts/tiles.xml</CODE>, but the individual pages live in <CODE>WEB-INF/views/*/tiles.xml</CODE>. This organizational structure is reflected in the configuration for Apache Tiles in the <CODE
        class="class-reference"
        module="spring-webmvc">org.springframework.web.servlet.view.tiles2.TilesConfigurer</CODE> above. </span></div>
<P> Now, when a Spring MVC controller returns <CODE>"signin"</CODE>, the Tiles view definition named <CODE>signin</CODE>
    will be loaded and rendered. </P>

<h3>Rendering Resources with the Default Servlet </h3>

<P> Our application already has a lot going for it, but we're not done. You'll recall from our configuration in <span
        module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer</span>,
    that we <EM>mapped</EM> the Spring <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.DispatcherServlet</CODE>
    to <CODE>/*</CODE>. <EM>All</EM> requests going to this application will be routed to the Spring MVC <CODE>DispatcherServlet</CODE>
    with this configuration. There, the <CODE>DispatcherServlet</CODE> will look for a Spring bean annotated with <COde>@Configuration</COde>
    to handle the request. What happens if the request isn't handled by a <CODE>@Controller</CODE>-annotated bean? What
    then? What, for example, handles requests for <CODE>*.js</CODE> and <CODE>*.css</CODE> resources? </p>

<P> Normally, if no Servlet was mapped to handle a request, the <EM>default</EM> or <EM>file</EM> Servlet provided by
    the Servlet container handles it. This <EM>default</EM> Servlet's pre-built, usually optimized for rendering
    resources out of the web application, and very fast. As we configured Spring MVC to handle <EM>all</EM> requests,
    however, we lose the services of this <EM>default</EM> Servlet. Fortunately, with Spring MVC we can have our cake
    and eat it too! </p>

<P> Spring MVC has a lot of functionality that you can override, or enable/disable, by implementing the interface <CODE
        class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.WebMvcConfigurer</CODE>.
    There are a <EM>lot</EM> of callback methods in this class that you can implement that give you the opportunity to
    specify a lot of Spring MVC's behavior. To keep our code cleaner and avoid implementing a lot of methods we don't
    care about, <code class="class-reference" module="web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</code>
    will extend <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter</CODE>,
    which implements <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.WebMvcConfigurer</CODE>
    with empty no-op methods. </P>

<P> To handle the resources with no mapped <CODE>Servlet</CODE>, we <EM>enable</EM> the default servlet in our <CODE>@Configuration</CODE>
    class. The default servlet is unique to each web container, and not specified by any standard. Spring MVC can be
    made to depend on this functionality, if it's available, if you <EM>enable</EM> it. It supports a wide range of
    deployment targets, though - so chances are it will work for you if you're running this application in Tomcat,
    Jetty, JBoss, and GlassFish, Google App Engine, Resin, WebLogic or WebSphere. Here's our revised configuration
    class, this time enabling the <EM>default</EM> Servlet. </P>

<div class="git-gist" gist="5060799"> defaultServlet.enable()</div>
<P> Once we have the <EM>default</EM> servlet in place, we can put it to work, letting it render a few resources we
    don't want to write handlers for ourselves. This will automatically employ the <EM>default</EM> servlet to render
    all requests to <code>/web/*</code> and render the appropriate resource in the <CODE>/web/</CODE> directory in the
    web application. </P>

<Div class="git-gist" gist="5060815"> addResourceHandlers()...</Div>
<h3> View Controllers </h3>
<!-- now we need to introduce how to handle view controllers. but the things is, theyve not yet seen the full controllerl ifecycle. so perhaps i can introduce that above? -->
<P> Some pages in an application are read-only - they don't require any functionality or processing logic. It would seem
    silly to implement a controller and a request handler just to render a view. Spring MVC can handle this eventuality
    easily: simply declare <EM>view controllers</EM> in the configuration class by overriding the <CODE>addViewControllers</CODE>
    method, like this: </P>

<div class="git-gist" gist="5067566"> addViewControllers()</div>
<P> Here, we use the <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.ViewControllerRegistry</CODE>
    to map URLs to view names. For example, <CODE>/</CODE> gets mapped to <CODE>/signin</CODE>, so that the first page
    anyone sees is the signin form. We also map other URLs (like <CODE>/crm/signin.html</CODE>) to appropriate views -
    in this case, <CODE>signin</CODE>. </P>

<P> While we're taking care of these sorts of things, let's configure an error handling page. If a component in our web
    application throws an exception, Spring MVC can redirect to an error page and optionally return an error code for
    us. For now, we'll install a catch-all error page view by overriding the
    <CODE>configureHandlerExceptionResolvers</code> method. Here, we've specified that the view named <CODE>oops</CODE>
    (which we defined above as a <EM>view controller</EM>) is to be rendered whenever there's an error, and a <span
            class="wikipedia">HTTP_404</span> code is to be returned. </P>

<div class="git-gist" gist="5067711"> configureHandlerExceptionResolvers</div>
<h3> Where do I Put Common Logic Across All Requests? </h3>

<P> There is some data that is reprinted as part of the Apache Tiles template on every page - data like the sign-in
    <CODE>user</CODE>s ID and username. This is information we could derive from the <CODE>user</CODE> itself. Instead
    of making a mess of the session simply to dereference values, and instead of long expressions in our templates,
    we'll simply recreate the values in a common place that gets executed across <EM>all</EM> requests to the
    application. Let's take advantage of Spring MVC's powerful <EM> <A
            href="http://static.springsource.org/spring-framework/docs/current/spring-framework-reference/htmlsingle/#mvc-config-interceptors">
        interceptor</a></EM> support. The values we want, specifically, are the user's <CODE>userId</CODE>, and <CODE>username</CODE>.
    These values can be made available inside the interceptor, and then dereferenced from our controllers and templates.
    That way, when we later change the way we lookup the current, authenticated user, the templates will need not change
    accordingly. We simply change our <code class="class-reference" module="spring-webmvc">org.springframework.web.context.request.WebRequestInterceptor</code>
    implementation and the values will update accordingly. </p>

<P> The <CODE>WebRequestInterceptor</CODE> SPI lets you act on all requests, before a request has been handled by a
    Spring MVC controller (<CODE>preHandle(WebRequest req)</code>), after a request has been handled by a Spring MVC
    controller (but before the <EM>view</EM> has been rendered; (<CODE>postHandle(WebRequest req, ModelMap model)</code>)),
    and after Spring MVC has finished processing the request entirely (<CODE>afterCompletion(WebRequest request,
        Exception ex)</code>). Our code simply inspects the current HTTP session (if it's available) and extracts
    information about the authenticated user and puts that information in the request attributes where it's available
    from inside of the view. </P>

<div class="git-code" extension="java" q="tut_web" module="web">
    org.springsource.examples.spring31.web.interceptors.CrmHttpServletRequestEnrichingInterceptor
</div>
<P> We need only override one more method in the <CODE class="class-reference" module="web" q="tut_web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</CODE>,
    <CODE>addInterceptors</CODE>, to register our custom interceptor, like this: </P>

<Div class="git-gist" gist="5087185"> addInterceptors()</Div>
<h3> Internationalization </h3>

<P> We don't live in monolingual world, and web applications can't afford to ignore the languages their users speak.
    Spring MVC can detect the <em>locale</em> from each users HTTP requests. This can be used to give our application an
    idea about what language the user is expecting language strings to be rendered in. Spring MVC can look up message
    strings in <EM>resource bundles</EM>. The JDK supports <CODE class="class-reference" module="java">java.util.ResourceBundle</CODE>s,
    which map a given key and language combination to a string in a specific language and localized to a specific
    region. </p>

<div style="margin-bottom: 10px" class="diagram">
    <table>
        <thead>
        <TR>
            <th> Language</th>
            <th> Language Code</th>
            <th> Country Code</th>
            <Th> Example Resource Bundle File Name</Th>
        </TR>
        </thead>
        <TR>
            <td>English</td>
            <td>en</td>
            <td>(none)</td>
            <TD><CODE>messages_en.properties</CODE></TD>
        </TR>
        <TR>
            <td>French</td>
            <td>fr</td>
            <td>(none)</td>
            <TD><CODE>messages_fr.properties</CODE></TD>
        </TR>
        <TR>
            <td>German</td>
            <td><CODE>de</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_de.properties</CODE></TD>
        </TR>
        <TR>
            <td>Italian</td>
            <td><CODE>it</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_it.properties</CODE></TD>
        </TR>
        <TR>
            <td>Japanese</td>
            <td><CODE>ja</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_ja.properties</CODE></TD>
        </TR>
        <TR>
            <td>Chinese</td>
            <td><CODE>zh</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_zh.properties</CODE></TD>
        </TR>
        <TR>
            <td>Chinese Spoken in China</td>
            <td><CODE>zh</CODE></td>
            <td><Code>CN</Code></td>
            <TD><CODE>messages_zh_CN.properties</CODE></TD>
        </TR>
        <TR>
            <td>Chinese Spoken in Taiwan</td>
            <td><COde>zh</COde></td>
            <td><CODE>TW</CODE></td>
            <TD><CODE>messages_zh_TW.properties</CODE></TD>
        </TR>
        <TR>
            <td>French Spoken in France</td>
            <td><code>fr</code></td>
            <td><CoDE>FR</CoDE></td>
            <TD><CODE>messages_fr_FR.properties</CODE></TD>
        </TR>
    </TABLE>
    <span class="caption"> Some common country code and language code designations and an example properties file name for that language and/or country. </span>
</div>
<P> Resource bundles contain locale-specific objects. When your program needs a locale-specific resource, a
    <CODE>String</CODE> for example, your program can load it from the resource bundle that is appropriate for the
    current user's locale. In this way, you can write program code that is largely independent of the user's locale. We
    register an instance of <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.i18n.SessionLocaleResolver</CODE>
    to detect the current users <CODE>Locale</CODE> and store it for reference in the session. The <CODE>Locale</CODE>
    stored in the HTTP session can be overriden with a request parameter. We enable this by installing one more <EM>interceptor</EM>,
    an instance of the <CODE class="class-reference" module="spring-webmvc">
        org.springframework.web.servlet.i18n.LocaleChangeInterceptor </CODE>. Finally, we register an instance of <CODE
            class="class-reference" module="spring-webmvc">org.springframework.context.support.ResourceBundleMessageSource</CODE>
    which looks at resource bundles for translation keys having a <code>basename</code>. We've specified the <CODE>basename</CODE>
    <code>messages</code>. Thus, if a user's <CODE>Locale</CODE> indicates that the user speaks the German language (de)
    in Switzerland (CH), Spring MVC will attempt to load <CODE>messages_de_CH.properties</CODE>, before then trying the
    more generic <CODE>messages_de.properties</CODE> for all German-language speaking countries. If that doesn't work,
    it'll fall back to the resource bundle for the specified <Em>default</Em> <CODE>Locale</CODE>. We'll look at how
    this internationalization support can be used in our application later when we introduce form validation and
    demonstrate how to create templates with internationalized strings. </P>
<!-- todo i18n && MessageSource should be covered more in the first -core Spring - tutorial --> <P class="todo">For more
    on Spring's <code module="spring-webmvc" q="tut_web" class="class-reference">org.springframework.context.MessageSource</code>,
    please see the first tutorial on core Spring. </P>

<div class="git-gist" gist="5115482"></div>
<H3>Final Configuration</H3>

<P> Our application can now serve complex pages using Apache Tiles, JSP, and we can easily stream resources like
    JavaScript and CSS files. We've setup Spring MVC and now we can move on to the final leg of this tour through basic
    Spring MVC. </P>

<div module="web" q="tut_web" extension="java" class="git-code">
    org.springsource.examples.spring31.web.config.WebMvcConfiguration
</div>
<h2>Building A Simple Sign In Page with a Form </h2>

<P> Let's build our first view, supporting basic login, which requires form processing. The implementation logic for
    this login page is in <span module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.ViewController</span>.
</p>

<div module="web" q="tut_web" extension="java" class="git-code">org.springsource.examples.spring31.web.ViewController
</div>
<P> The obvious things: this is a Spring MVC controller, that handles both HTTP <CODE>POST</CODE> and <CODE>GET</CODE>
    requests to the same URL, <CODE>/crm/signin.html</CODE>. Since all handlers in the class are for a common URL, we've
    mapped the URL in one place, at the class, in a <span class="class-reference" module="spring-webmvc">org.springframework.web.bind.annotation.RequestMapping</span>.
    There are some values that are shared in multiple places, so those values are stored as <CODE>public static final
        String</CODE> values in the class. </P>

<p> We have two use cases. How will people arrive at this form? They'll visit the URL <CODE>/crm/signup.html</CODE> in
    their browser. That requires handling an HTTP <CODE>GET</CODE> call. The request handler doesn't do anything, it
    simply renders the view provided. </p>

<div class="git-gist" gist="5114686"></div>
<P> Then, once the users have landed, they'll input values into the form (data that we will want to work with in terms
    of a <code>SignInAttempt</code> object) and then submit, or <CODE>POST</CODE> the data to the URL <CODE>/crm/signup.html</CODE>.
    That requires handling an HTTP <CODE>POST</CODE> call that contains form data that needs to be validated. </p>

<div class="git-gist" gist="5114830"></div>
<P> The values will come from the client in the request as the request parameters <code>username</code> and <CODE>password</CODE>.
    As written, the request handler declares three parameters of type <CODE class="class-reference" module="web"
                                                                            q="tut_web">org.springsource.examples.spring31.web.SignInAttempt</CODE>,
    <code class="class-reference" module="spring-webmvc">org.springframework.validation.BindingResult</code>, and <code
            class="class-reference" module="spring-webmvc">org.springframework.ui.Model</code> respectively. The first
    argument - of type <span class="class-reference" module="web" q="tut_web"> org.springsource.examples.spring31.web.SignInAttempt</span>
    - is annotated with two annotations: <CODE class="class-reference" q="spring-webmvc" module="spring-webmvc">org.springframework.web.bind.annotation.ModelAttribute</CODE>
    and <CODE module="servlets" class="class-reference" q="spring-webmvc">javax.validation.Valid</CODE>. Let's look
    first at the <span class="class-reference" module="web" q="tut_web"> org.springsource.examples.spring31.web.SignInAttempt</span>.
</p>

<DIV class="git-code" extension="java" module="web" q="tut_web">org.springsource.examples.spring31.web.SignInAttempt
</DIV>
<P><CODE class="class-reference" q="spring-webmvc" module="spring-webmvc">org.springframework.web.bind.annotation.ModelAttribute</CODE>
    tells Spring MVC that the request handler is expecting an object of the type annotated. By default, Spring MVC will
    attempt to instantiate an instance of the class using a <EM>default</EM> constructor. It will use JavaBean
    conventions and set properties on the object based on request parameters. Thus: the <CODE>SignInAttempt</CODE>
    object will be created, and its <CODE>username</CODE> field will be set from the HTTP request attribute <CODE>username</CODE>,
    and its <Code>password</Code> field will be set from the HTTP request attribute <CODE>password</CODE>. </P>

<P> If you want to synthesize the model object yourself - perhaps because you want to call a different constructor or
    build the object based on more than just request parameters - you can annotate a factory method with <CODE
            class="class-reference" q="spring-webmvc" module="spring-webmvc">org.springframework.web.bind.annotation.ModelAttribute</CODE>.
    This factory method can access anything from the request it wants. We could declare our own
    <CODE>@ModelAttribute</CODE> factory method in the controller to construct the <span class="class-reference"
                                                                                         module="web" q="tut_web"> org.springsource.examples.spring31.web.SignInAttempt</span>.
    <CODE>@ModelAttribute</CODE> factory methods can declare all the same arguments as request handlers. Here's a <code>@ModelAttribute</code>
    factory method that uses a non-default constructor. </P>

<DIV class="git-gist" gist="5114560">@ModelAttribute public SignInAttempt signInAttempt</DIV>
<P><CODE>@Valid</CODE> is a <em>Java Validation API</Em> (<A href="http://jcp.org/en/jsr/detail?id=303">JSR 303</A>)
    annotation that signals that the bean it annotates has <EM>constraint</EM> annotations declared on its fields. These
    <EM>constraints</EM> are declarative. The class is a regular Java Object that declares two String fields, named the
    same as the request parameters: <CODE>username</CODE> and <CODE>passsword</CODE>. It has a default constructor, and
    the fields have accessor (<code>get*</code>) and mutator methods (<code>set*</code>). It also declares validation
    constraints through annotations on each field. For example, the <COde>username</COde> field is required to have a
    valid, non-empty email string: </P>

<DIV class="git-gist" gist="5114717"> @Email private String email ;</DIV>
<P> Spring MVC will make any errors available for us in our second argument, an instance of <CODE
        class="class-reference" q="tut_web" module="spring-webmvc">org.springframework.validation.BindingResult</CODE>.
    In the code for the request handler, we use the <CODE>BindingResult</CODE> to check for errors and short circuit an
    attempt to login and - if we proceed with the login but encounter an error - to register new errors. We use the
    <CODE>reject</CODE> method to signal that the attempt to login failed to return a valid reference. We give the
    method a <EM>message code</EM> (<code>login.invalid</code>) and a default error message to be rendered if the
    message code doesn't exist yet (this is useful for debugging purposes). We'll look more at message codes in the next
    section. </P>

<p>Finally, we declare an argument of type <CODE>Model</CODE>, which is basically a glorified hash map that stores
    values in the various web server memory storage caches: the current HTTP request context, the HTTP session context,
    etc. By default values are stored and endure as long as the request they're created for. Because we want the model
    object for the <CODE>user</CODE> to live for as long as the current user is signed in, we use the <CODE>@SessionAttributes(ViewController.USER_OBJECT_KEY) </CODE>
    at the class level to signify that the <code>user</code> model attribute should be stored in the HTTP session.
    Values in the <CODE>Model</CODE> object are also available for reference during the render. We use this object to
    store the authenticated user into the model attribute <code>user</code>. </p>

<P> If there are any errors, the method returns the String <CODE>"signin"</CODE> to signal that <CODE>signin</CODE> view
    should be re-rendered to present the user with feedback about the errors. If there are no errors, the method returns
    the String <CODE>"redirect:/crm/profile.html"</CODE>, which Spring MVC will handle by sending a redirect (a separate
    <CODE>HTTP GET</CODE> call) to the user's <code>profile</code> page. </P>

<h3> Internationalization with Spring MVC </h3>

<p> In the previous section, we used the <code>reject</code> method on the <CODE>BindingResult</CODE> argument to
    register an error, passing in a <EM>message code</EM> that corresponds to a message in the resource bundle we setup
    earlier in our configuration class. As explained earlier, Spring MVC will look up the message key based on the
    current HTTP session's <CODE class="class-reference" module="java">java.util.Locale</CODE>. Let's look at the page
    markup for the sign in form: </P>

<div module="web" q="tut_web" class="git-code" extension="jsp"> src/main/webapp/WEB-INF/views/signin/signin.jsp</div>
<P> The page is a standard <CODE>.jsp</CODE> page that relies on the Apache Tiles tags (defined by the tag namespace
    <CODE>http://tiles.apache.org/tags-tiles</CODE>) to enclose a region of markup and set it as the value to be
    rendered in the <CODE>content</CODE> tile in the Tiles layout. </p>

<P> The page also relies on the Spring tags, defined by the tag namespace
    <CODE>http://www.springframework.org/tags</CODE> to setup the form, and to handle dealing with presenting
    internationalized errors and text labels to the user. The declaration <CODE> &lt;form:errors element="li" path="*"/&gt;</CODE>
    tells Spring MVC to render the errors currently stored in the <CODe>BindingResult</CODe> inside of <CODE>
        &lt;li&gt;</CODE> elements. We use the <CODE>path</CODE> attribute to tell Spring MVC that it should render <EM>all</EM>
    errors. In the template itself - and throughout the site - wherever user prompts are expected, we use the <CODE>&lt;spring:message
        code =".." &gt;</CODE> element to import text resources from the resource bundle based on a key. Both the label
    handling and the error handling rely on Spring's internationalization support. </P>

<P> The <CODE>&lt;spring:form&gt;</code> tag establishes that we expect the fields in this form (one for
    <CODE>username</CODE> and one for <CODE>password</CODE>) to be mapped to a <EM>command object</EM> - which refers to
    the same object as the <CODE>@ModelAttribute</CODE>-annotated argument to the HTTP <CODE>POST</CODE> request
    handler. </P>

<P> The rest of the page is standard HTML markup to render an HTML form complete with interactive JavaScript feedback
    and styling. We now have a working sign in form! </P>

<h1> The Changing Face of the Web: Working with Business State using REST </h1>

<h2> The Smarter Client </h2>

<P>

<div style="float:left;margin-right:10px; width: 520px;">
    <div style="margin-bottom: 10px" class="diagram"><img src="images/green-screen-dinosaur.jpg"/> <span
            class="caption"> Computer monitors used to come in three colors: green, white, and amber, always on a black background. </span>
    </div>
    <div style="margin-bottom: 10px" class="diagram"><img src="images/tim-berners-lee-NextCube.jpg"/> <span
            class="caption"> Tim Berners-Lee's NextStep Cube. I love the warning on the machine - "This machine is a server. DO NOT POWER DOWN!!" Imagine the implications! Imagine <EM>powering
        down</EM> <B>the web</B>! Eeery. </span></div>
</div>
Before the 'web, we had mainframes and thin clients. These clients were remarkably stupid. No client side state at all.
The server would send down the updates to the clients and the clients would render them. Every time. <a
        href="http://www.w3.org/People/Berners-Lee/">Tim Berners-Lee</a> invented the World Wide Web while at CERN, the
European Particle Physics Laboratory, in 1989. He wrote the first web client and server in 1990. His specifications of
URIs, HTTP and HTML were refined as Web technology spread. The initial makeup of the web was fairly underwhelming. The
first several years were uneventful because the clients - HTTP browsers - were no more impressive than the green-screen
clients they replaced. They were dumb. <EM>Very</EM> dumb. Slowly, functionality was added to make the browsers smarter.
As time progressed, the community devised of stopgap solutions to make the web a nicer place to build web applications.
These were, on the whole, hacks. As time progressed, these hacks were baked into the browsers and into the standards
driving HTTP, HTML and the web in general. </P><P> To keep pace, the client-side browsers have taken a quantum leap in
    the last decade! Now, we have <EM>really</EM> smart clients. JavaScript, the language that runs within the browsers,
    has grown by leaps and bounds and can do <EM>almost </EM> anything. Witness, for example, <a
            href="http://bellard.org/jslinux/">this JavaScript PC emulator by Fabrice Bellard </a>. It boots Linux.
    Seriously. When you run it, it dumps you into a shell where you can use <code>vi</code> to edit the file <CODE>hello.c</CODE>.
    Then, you can recompile it and run it. All within Linux. Inside of a browser. Using an emulator written in
    JavaScript. </P> <!-- todo link to our tutorial on cujos--> <P> What role does the server play here? While
    individual resources, such as CSS and images and JavaScript, are served up by the web server, and while initial HTML
    pages are sent down from the server, much of the interaction that happens between the user and the user interface
    happens these days entirely on the client. The server doesn't really need to get involved too much in rendering
    HTML, besides serving the initial page load and the resources to support it. Nowadays, the client can do a
    <EM>lot</EM> of interesting things, and doesn't need to rely on the server to keep user-interface state. Indeed all
    the server has to do is keep <EM>business</EM> state, and make that available to the client. </p>

<P> Today, <span class="wikipedia"> REST </span> (or <EM>representational state transfer</EM>) is the most common way to
    expose server side business state to clients. REST builds upon the principles of HTTP, so doesn't require any new
    infrastructure or any specialized types of middleware. There are some fundamental principles behind REST. </p>

<H2> Designing RESTful Resources with Spring </H2>
<!-- todo interleave the relevant Spring MVC handler method syntax as u introduce concepts for REST--> <P> Spring's
    support for REST builds upon the basic Spring MVC component model. You've already been introduced to Spring MVC
    controllers, and so are more than halfway there. Our application deals with two different types of data, or
    entities: <CODE class="class-reference" q="tut_rest" module="services">
        org.springsource.examples.spring31.services.User </CODE> and <CODE class="class-reference" q="tut_rest"
                                                                           module="services">
        org.springsource.examples.spring31.services.Customer</CODE>. We'll build RESTful web services to support
    manipulating these entities. Let's add a controller - <CODE class="class-reference" q="tut_rest" module="web">org.springsource.examples.spring31.web.UserApiController</CODE>
    - which will manage the <COde>User</COde> information. The controller will expose endpoints to handle common
    operations for a <CODE>User</CODE>. A <CODE>User</CODE> will login, manage her profile, and manage
    <CODE>Customer</CODE> records. First, let's look at the code, then we'll dissect the novel parts. </P>

<div module="web" q="tut_rest" extension="java" class="git-code">
    org.springsource.examples.spring31.web.UserApiController
</div>
<P> This code should look fairly familiar. It's a set of Spring MVC controllers that deal with requests to various URIs.
    There are a couple of novel things in this code, however. </P>

<h3> URI Structures </h3>

<p> HTTP resources (URIs) map to data hierarchies, like directory structures, in an easily understood way. Suppose, for
    example, that you want to map customer data from a CRM-style application (like ours!) to HTTP URIs. You might use
    <code>http://localhost:8080/crm/customers</code> to expose <EM>all</EM> the customers. You might use <CODE>http://localhost:8080/crm/customers/42</CODE>
    to expose information specifically about a customer whose ID is <CODE>42</CODE>. You might use <CODE>http://localhost:8080/crm/customers/42/orders</CODE>
    to expose information about the <CODE>orders</CODE> of that same <CODE>customer</CODE>. Here's the request handler
    to retrieve <CODE>User</CODE> data by ID. </p>

<DIV class="git-gist" gist="5129983"> @RequestMapping @ResponseBody public void userById( @PathVariable ...)</DIV>
<P> This method is very similar to the request handlers we've seen thus far! It has a <CODE class="class-reference"
                                                                                            module="spring-web">org.springframework.web.bind.annotation.RequestMapping</CODE>
    annotation establishing the method as a handler. It specifies a URL and an HTTP method (<CODE>GET</CODE>) that it
    can respond to. </P>

<P> The <CODE>public static final</CODE> field, <CODE>USER_COLLECTION_ENTRY_URL</CODE>, is a <CODE>String</CODE> that
    we've defined once and built upon to ensure consistent URIs. The final URL is <CODE>/api/users/{userId}</CODE>. </P>
<CODE class="git-gist" gist="5130002"> static public final String USER_COLLECTION_URL = "/api/users"; static public
    final String USER_COLLECTION_ENTRY_URL = USER_COLLECTION_URL + "/{userId}"; </CODE>

<P> Any token contained in braces (like: <CODE>{userId}</CODE>) is a <EM>path variable</EM>. Spring MVC will treat that
    as a wild card, extract the value out from each request and inject the value into any request handler method
    argument annotated with <CODE class="class-reference" module="spring-web">org.springframework.web.bind.annotation.PathVariable</CODE>,
    like this: <CODE>@PathVariable("userId") Long userId</CODE>. If, for example, someone opened the URL <CODE>/api/users/24</CODE>
    in a browser, the request handler method (<CODE>getUserById</CODE>) would be invoked and the value <CODE>24</CODE>
    would be converted to a type of <CODE class="class-reference" module="java">java.lang.Long</CODE> and passed as an
    argument to our controller method. Of course, path variables are just as naturally used with regular Spring MVC and
    <EM>classic</EM> web applications. </P>

<h3>Content Negotiation and HTTP Message Conversion </h3>

<P> The return value is annotated with the <CODE class="class-reference" module="spring-webmvc">org.springframework.web.bind.annotation.ResponseBody</CODE>
    annotation. When Spring MVC sees this annotation, it short circuits the view resolution process that's normally at
    play and then attempts to convert the returned value into a representation that the HTTP client can work with. The
    client signals which representation formats it's prepared to accept through a process called <EM>content
        negotiation</EM>, a fundamental feature of HTTP. Usually, the client sends a <CODE>Accept</CODE> header that
    specifies which representation formats it's prepared to read. </p>

<P> On the server side, Spring MVC uses the <EM>strategy pattern</EM> to delegate the conversion to a configured <CODE
        class="class-reference" module="spring-webmvc">org.springframework.http.converter.HttpMessageConverter</CODE>
    instance. Depending on what is available on your CLASSPATH, Spring MVC will automatically support marshalling XML
    with a JAXB implementation and JAXB-annotated POJOs, JSON through the Jackson JSON library, multipart file data
    through the <A href="http://commons.apache.org/proper/commons-fileupload/">Apache Commons FileUpload </A> library or
    the Servlet 3 Part API, RSS and ATOM feeds with the ROME library, and images using the <code>java.awt.image.BufferedImage</code>
    API and more. Thus, if a client requests the data in one of these URLs and species that it will only
    <CODE>Accept</CODE> data of the type <CODE>application/json</CODE>, then the server will attempt to convert the
    results into JSON and send it in the response body. </p>
<!-- todo diagrams showing the XML and JSON representations of data -->
<div class="diagram" style="width:800px;">
    <TABLE width="100%">
        <thead>
        <TR>
            <th><CODE> Accept: application/json</CODE></th>
            <th><CODE> Accept: application/xml</CODE></th>
        </tr>
        </thead>
        <TR>
            <TD><span class="git-gist" gist="5154456"></span></TD>
            <TD><span class="git-gist" gist="5154481"></span></TD>
        </TR>
    </TABLE>
    <span class="caption"> I use the command line tool <CODE>curl</CODE> to call the REST service, like this: <br/> <STRONG><code>$
        curl --header "Accept: application/xml" http://localhost:8080/api/users/58 </code></STRONG> </span></div>
<h3> Serializing Hibernate Objects over HTTP </h3>

<P> You don't often have to override the configured <CODE>HttpMessageConverters</CODE>, but it's nice to know that you
    can. You simply override the <code>configureMessageConverters</code> method in the configuration class. In this
    method, you're given a reference to a list of <CODE>HttpMessageConverters</CODE>, which you may populate however you
    like. However, if you don't provide anything, then Spring MVC will install the default converters. </p>

<P> Our application works with domain model objects that describe a <CODE>User</CODE> and a <CODE>Customer</CODE> data.
    These domain model objects are plain old POJOs that work with <A href="http://hibernate.org">Hibernate</A>, a
    popular object-relational mapping framework. Our domain model objects are annotated with JPA and JAXB annotations.
    JPA annotations describe the layout of the object to a JPA provider like Hibernate so that it can effectively pick
    apart the important values in the object and save them to a database table. JAXB annotations describe the layout of
    the object to a JAXB provider so that it can effectively pick apart the important values in the object and write
    them out as an XML document. Our POJOs don't need any changes to work with Jackson, which converts objects to and
    from JSON. </P>

<P> Unfortunately, there's still a small fly in our ointment. Our <CODE>User</CODE> objects maintain a collection of
    <CODE>Customer</CODE> records. This is a typical <EM>master-detail</EM>, or <EM>one-to-many</EM> arrangement.
    Unfortunately, these <CODE>User</CODE> entities in turn have a reference to the <CODE>User</CODE> objects to which
    they belong creating a circular reference. Circular references are easy to manage in Hibernate, but the Jackson
    library that handles the conversion of an object to and from JSON for Spring MVC doesn't like it so much. It
    ultimately leads to a stack overflow. There are a few well known solutions. One of them is to tailor the <CODE>ObjectMapper</CODE>
    used by the registered <CODE class="class-reference" module="spring-web">org.springframework.http.converter.json.MappingJacksonHttpMessageConverter</CODE>.
    We'll rely on a third party library that provides a <CODE>ObjectMapper</CODE> implementation that knows how to
    simply ignore relationships that could cause a circular relationship. This also has the benefit of not sending all
    the <CODE>Customer</CODE> data on each request. </P>

<DIV class="git-gist" gist="5157555"> MappingJacksonHttpMessageConverter mappingJacksonHttpMessageConverter = new
    MappingJacksonHttpMessageConverter(); mappingJacksonHttpMessageConverter.setObjectMapper(new
    HibernateAwareObjectMapper()); mappingJacksonHttpMessageConverter.setSupportedMediaTypes(Arrays.asList(
    MediaType.APPLICATION_JSON )); messageConverters.add(mappingJacksonHttpMessageConverter);
</DIV>
<P> The <CODE class="class-reference" module="web">org.springsource.examples.spring31.web.util.HibernateAwareObjectMapper</CODE>
    class simply installs the <CODE>HibernateObjectMapper</CODE> provided by the third party library. And, just like
    that, we can serialize Hibernate POJOs using JSON. This is yet another example where Spring makes possible the
    impossible possible, and easier the difficult chores of enterprise application development. </P>

<h3>HTTP Verbs</h3>

<p> HTTP methods should be used explicitly. HTTP methods (<CODE>POST</CODE> , <CODE>DELETE</CODE>, <CODE>PUT</CODE>,
    <CODE>GET</CODE> map nicely to the state transitions (creation, deleting, updating, reading and querying,
    respectively) our enterprise data typically goes through. </p>
<ul>
    <LI><CODE>GET</CODE>, for example, can be used to retrieve information. It must be safe, and idempotent. It can have
        side effects, but since the user doesn't expect them, they shouldn't be critical to the operation of the system.
        GET can be conditional or partial based on the presence of the HTTP headers <CODE>If-Modified-Since</CODE> or
        <COde>Range</COde>. A HTTP <CODE>GET</CODE> request looks like this: <CODE>GET /api/crm/42/customers/242</CODE>.
        This would be expected the entity identified by <CODE>242</CODE> holding customer data.
    </LI>
    <LI><CODE>DELETE</CODE>s can be used to delete information identified by a URL. A <CODE>DELETE</CODE> request looks
        like this: <CODE>DELETE /api/crm/42/customers/242</CODE>. A <CODE>DELETE</CODE> request can
    </LI>
    <LI> Usually, a <CODE>PUT</CODE> requests that the payload of the request be used to update or create a resource on
        the server with a specific ID. Thus, <CODE>PUT /api/crm/42/customers/243</CODE> might create a new customer
        record identified by the number <CODE>242</CODE>, and can return a response. Such a response might be <CODE>{
            "name" : "Mark", "id" : "242" }</CODE>.
    </LI>
    <LI> Usually, a <CODE>POST</CODE> requests that the payload of the request be used to update or create a resource on
        the server with <EM>no</EM> specific ID. Thus, <CODE>POST /api/crm/42/customers</CODE> might create a customer
        record and then return that as the response, just as with <CODE>PUT</CODE>: <CODE>{ "name" : "Mark", "id" :
            "242" }</CODE>. You might respond with an HTTP status code. For example, you could return an <CODE>HTTP 201
            Created</code> code and a <CODE>Location</CODE> header with the URI that points to the newly created
        resource.
    </LI>
</ul>
<P> Our request handlers are often mapped to the same URI, differing only on the type of HTTP verb that the controller
    is prepared to support. In the example below, we support one request handler to </P>

<DIV class="git-gist" gist="5154652"> @RequestMapping(POST) @RequestMapping(GET)</DIV>
<h3>HTTP Status Codes </h3>

<P> HTTP supports status codes to convey system state to clients in a consistent way. These take the place of things
    like exceptions in programming languages. Status codes are an indicator of the result of the server's attempt to
    satisfy the request. These status codes are returned in the response from the server. Spring MVC provides an enum
    (<CODE class="class-reference" module="spring-web">org.springframework.http.HttpStatus</CODE>) of common HTTP status
    codes. Status codes are broadly divided in categories: </P>
<ul>
    <LI><b>1XX</b>: Informational</LI>
    <LI><b>2XX</b>: Success</LI>
    <LI><b>3XX</b>: Redirection</LI>
    <LI><b>4XX</b>: Client Error</LI>
    <LI><b> 5XX</b>: Server Error</LI>
</ul>
<P> By default Spring returns HTTP <CODE>200</CODE> on successful requests. HTTP <CODE>200</CODE> means "everything
    worked." You don't need to indicate this status code if everything succeeds. You can, in specific cases, provide a
    different status code using the <CODE module="spring-webmvc" class="class-reference">org.springframework.web.bind.annotation.ResponseStatus</CODE>
    annotation on the Spring MVC request handler or by setting it manually. You don't need to specify a particular
    status code for most errors, however, as Spring MVC already knows how to map certain types of Spring MVC exception
    types to HTTP status codes. </P>

<P> The convention for handling HTTP <CODE>POST</CODE> requests that create a resource is to send the status code <CODE>201</CODE>,
    which means <CODE>CREATED</CODE>, along with a <CODE>Location</CODE> header that provides the URI for the newly
    created resource. In our controller, the <CODE>registerUser</CODE> method adds a user to the system by accepting
    HTTP request data, delegating to an injected service instance (<COde>userService</COde>) and then returning a
    response that contains a <CODE>Location</CODE> header that indicates the location of the newly created resource. The
    <CODE>Location</CODE> is simply a URI built using the injected instance of the <CODE class="class-reference"
                                                                                         module="spring-webmvc">org.springframework.web.util.UriComponentsBuilder</CODE>,
    a convenience class that Spring MVC provides to build up URIs - both relative and absolute - complete with support
    for path variable expansion. This method returns an instance of Spring MVC's <CODE class="class-reference"
                                                                                       module="spring-web">org.springframework.http.ResponseEntity</CODE>
    class. <CODE>ResponseEntity</CODE> is a generic envelope type that holds a payload - the response to be rendered or
    marshalled - and any other data that might be in a response such as status codes and header values. In this example,
    we pass in a payload (<CODE>user</CODE>), headers to emit in the response (<CODE>httpHeaders</CODE>), and an HTTP
    status code (<CODE>HttpStatus.CREATED</CODE>) in the <CODE>ResponseEntity</CODE> constructor. Spring MVC will unpack
    the payload (the <CODE>user</CODE>) and marshall it just as it would have any other object, and it will send the
    status code and headers in the response. </P>

<DIV class="git-gist" gist="5154769"> @RequestMapping(value = USER_COLLECTION_URL, method = RequestMethod.POST) public
    ResponseEntity [User] registerUser ...
</DIV>
<h3> Reading and Writing Uploaded File Data over HTTP </h3>

<P> Our users have profile photos. These photos are stored as <CODE>byte</CODE>s using the <CODE>userService</code>
    (which in turn writes to <A href="http://docs.mongodb.org/manual/applications/gridfs/"> MongoDB's GridFS
        abstraction</A> using Spring Data MongoDB's <CODE class="class-reference" module="spring-data-mongodb">org.springframework.data.mongodb.gridfs.GridFsTemplate</code>).
    Our controller supports <CODE>POST</CODE> at <CODE>/api/users/{userId}/photo</CODE> to write the image that should
    be used for a given user's profile photo, and <CODE>GET</CODE> at <CODE>/api/users/{userId}/photo</CODE> to retreive
    (render) the image for a given user's profile photo. </P>

<P> Writing a user's profile photo is easy because of Spring's great support for file uploads. Our controller simply
    declares an argument of type <CODE class="class-reference" module="spring-webmvc">org.springframework.web.multipart.MultipartFile</CODE>.
    <COde>MultipartFile</COde> is an interface. There are two implementations supported out of the box: one that
    delegates to <A href="http://commons.apache.org/proper/commons-fileupload//">Apache Commons FileUpload library </A>
    and one that works via the Servlet 3 <CODE class="class-reference" module="servlets">javax.servlet.http.Part</CODE>
    API. Earlier, when we configured our Spring MVC application, we registered a <CODE class="class-reference"
                                                                                       module="spring-web">org.springframework.web.multipart.commons.CommonsMultipartResolver</CODE>
    that works with Apache Commons Fileupload. This has the benefit of working on any application server, not just one
    that supports Servlet 3. When Spring MVC receives a multipart encoded HTTP <CODE>POST</CODE>, it extracts the file
    data and makes it available via the <CODE>MultipartFile</CODE> argument. The <CODE>MultipartFile</CODE> argument
    provides access to everything you'd expect from the client about a file: the file name, the bytes for the file, its
    size, etc. </P>

<DIV class="git-gist" gist="5156244"> @RequestMapping(value = USER_COLLECTION_ENTRY_PHOTO_URL, method =
    RequestMethod.POST) @ResponseBody public Long uploadBasedOnPathVariable(@PathVariable("userId") Long userId,
    @RequestParam("file") MultipartFile file) throws Throwable { }
</DIV>
<P> Reading a file is even easier. Our request handler simply retrieves the <CODE>byte</CODE>s from our MongoDB
    GridFS-powered file repository, copies the <CODE>byte</CODE>s to a buffer, and then sends the whole thing with an
    HTTP <CODE>200</CODE> status code to the client. Earlier, we registered a <CODE class="class-reference"
                                                                                    module="spring-web">
        org.springframework.http.converter.ByteArrayHttpMessageConverter</CODE> that handles converting
    <CODE>byte[]</CODE> payloads to and from an HTTP request for us, so we're done! </P>

<DIv class="git-gist" gist="5156263"> renderMedia(HttpServletResponse, OutputStream, @PathVariable..)</DIv>
<h2> Exercising RESTful Web Services </h2>

<P> To familiarize yourself with an API, it can be helpful to interact with the endpoints and make calls against it and
    verify payloads. One of the nice things about REST is that it's basic HTTP so any modern day HTTP client will
    suffice as a way to exercise the service. Here are some of my favorite options. </P>

<h3>The Spring REST Shell </h3>

<P> The Spring REST Shell is a shell environment that lets you interact with RESTful resources in an interactive manner,
    much as though you were sitting at a <SPAN class="wikipedia">REPL</SPAN> for a scripting language. </P>

<P> Releases of the <A href="https://github.com/SpringSource/rest-shell">Spring REST Shell</A> can be downloaded from
    the GitHub <A href="https://github.com/jbrisbin/rest-shell/downloads"> rest-shell downloads </a> page or built from
    source. If you're using Mac OS X and <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, you can install the
    <code>rest-shell</code> using <code>brew install</code></P>

<P> Using the <CODE>rest-shell</CODE> to navigate your REST resources is very similar to traversing a directory
    structure in your system terminal. The <CODE>rest-shell</CODE> always maintains a <CODE>baseUri</CODE> that is
    considered the root to which all other path references are considered relative. If you have a REST service exposed
    at <CODE>http://localhost:8080/api/crm</CODE>, then you'd consider that your <CODE>baseUri</CODE>. </P>

<P> Once you have it running, it's easy to interact with it. Hit <CODE>TAB</CODE> to see more commands available.
    There's a lot more to be learned, and I won't endeavour to cover it all here, but let's look at an interactive
    session to understand more. </P>

<P> Once you've installed the <code>rest-shell</code>, simply launch the shell by invoking <CODE>rest-shell</CODE>. Once
    you're in the shell, you can get assistance on what to do next by typing <CODE>TAB</CODE>. </P>

<DIV class="git-gist" gist="5183821"></DIV>
<P> It's a simple matter to save typing by setting session-global directives, like the <CODE>baseUri</CODE> command.
    This sets the base URI relative to which all subsequent queries will build. </P>

<DIV class="git-gist" gist="5183823"></DIV>
<P> with the current <CODE>baseUri</CODE> set, you can simply issue queries, using intuitively named commands named
    after the HTTP versbs. </P>

<div class="git-gist" gist="5184448"></div>
<P> You can also invoke commands and have the output streamed to a file (perhaps for analysis later).</P>

<DIV class="git-gist" gist="5183825"></DIV>
<P> You can further customize your session by setting a header to be applied to all subsequent requests. Here we specify
    a <CODE>Accept</CODE> header value of <CODE>application/json</CODE> and then re-issue the same request as above,
    resuling in data in a different mime type. </P>

<DIV class="git-gist" gist="5183827"></DIV>
<P> For a more comprehensive look at the Spring <CODE>rest-shell</CODE>, consult the <A
        href="https://github.com/SpringSource/rest-shell/wiki/Getting-Started"><EM>Getting Started</EM></a> guide.</P>

<h3> Another Option: <CODE>curl</CODE></h3>

<P><CODE>curl</CODE> is a command line tool that ships on most Unix systems and can be used from Windows with the
    support of a Unix-emulation layer like <A href="http://cygwin.org">Cygwin</A>. <CODE>curl</CODE> can be installed on
    OSX using the <CODE>brew</CODE> package manager, like this: <CODE>brew install curl</CODE>. Once you've installed
    it, you can make requests on the command line, like this: </P>

<DIV class="git-gist" gist="5184517"></DIV>
<h3> Another Option: the Firefox Poster plugin</h3>

<P> The Firefox <A href="https://addons.mozilla.org/en-us/firefox/addon/poster/">Poster</A> plugin is a very capable
    little HTTP client, as well. You must install it from the Firefox market. </p>

<div class="diagram"><img src="images/poster%20-%20poster-icon.png"/> <span class="caption">Once installed, it appears as a little yellow icon in the bottom of the Firefox browser window. You can use it to interact with RESTful resources, as well. </span>
</div>
<DIV class="diagram"><img src="images/poster%20-%20poster%20request%20setup.png"/> <span class="caption"> Here, we make the same request as we did in the <CODE>curl</CODE> command above, this time by making a request and specifying a custom header in the <CODE>Header</CODE> tab. </span>
</div>
<div class="diagram"><img src="images/poster%20-%20poster-results.png"/><span class="caption">The content returned from the request will be displayed in a dialog, like this. </span>
</DIV>
<h1> Securing An Application with Spring Security </h1>

<!--
things ive added:
 -security.xlm
 - the spring security delegating filter to the initializer
 - the signin utils to the web configuration
 - the security configuration (including an added config reference on the         servletContext.addListener(new ContextLoaderListener(buildWebApplicationContext(servletContext, WebMvcConfiguration.class, SecurityConfiguration.class)));
 - security and oauth packages
- changing signin.jsp to use the correct form field names
 - change the web-inf/layouts/components/template.jsp to reflect ht euse of the sec:* namespace tags
- you can completely delete ViewController, couldn't you?

-->
<h2> An Insecure Application </h2>

<P> We've come a long way. Already our application works well enough and - to the untrained eye - the application would
    appear to be done. But, pull back the covers of the various screens in the application - particularly forms that
    transmit data and screens that read data from the server - and you'll see that the HTTP calls go unprotected without
    even the most basic of access checks. This doesn't bode well for our users who've trusted us with their confidential
    data. </p>

<P> Our application is functional, but not secure. Security is one of the hardest things to get right in an application.
    The conventional wisdom is that you shouldn't delay security until later in the application development cycle,
    because it needs to be grafted into the architecture and because - discipline under deadlines being what it is -
    people tend to do a poor job with security when they're in a hurry. </p>

<P> "Security" refers to many different concerns (including, but not limited to) the following: </p>
<uL>
    <LI><B>authentication </B> verification that a user is who she says she is</LI>
    <LI><B>authorization </b> - verification that a user has the permissions required to access or work with a resource
    </LI>
    <LI><B>encryption </B> refers to encoding data - particularly data transmitted over the network - in such a way that
        the data can't be read by unknown third parties.
    </LI>
</uL>
<P> Spring Security can help with all of those things. Spring Security is built on top of Spring, and through
    common-sense and elegance, makes short work of the common cases and makes the hitherto impossible things possible.
    It's fairly easy to see where our application could use better security, and we can build on Spring Security to
    improve our application. </p>
<OL>
    <LI> First, our sign in form is hand-rolled. Sign in functionality is something that almost all applications have to
        support, so why should we recreate that functionality each time?
    </LI>
    <LI> The pages in the application behind the sign-in form are completely unprotected: anyone could - given the URL -
        bring the page up in the browser, even if there is no logged in user session.
    </LI>
    <LI> Additionally, the client-side JavaScript code makes calls to unprotected REST resources that in turn do no
        authorization.
    </LI>
    <LI> No care is taken to prevent certain types of attacks intended to manipulate or steal a user's session.</LI>
    <LI> As a practical matter, our application doesn't currently support a <EM>sign out</EM> operation, and that's
        pretty important. It would be nice to have that, and do as little work as possible to get it.
    </LI>
</OL>
<P> Our application doesn't have <EM>roles</EM>, at the moment, but it's easy to see where they slot in. Suppose we let
    customers log into the system. The customers should not be able to update the profile information of the system user
    that manages the customer's account. That would be a bit presumptuous! With <EM>roles</EM> we could block access to
    certain parts of the application, based on the role assigned to that user. Conceptually, this separates the concept
    of access privileges from the user classes in your application. If we think ahead a little, it wouldn't be hard to
    imagine scenarios where it would be mighty useful to limit access to parts of our REST API based on roles as well,
    perhaps limiting access to resources for other users, creating a tier of users - <EM>administrative</EM> users, and
    <EM>regular</EM> users. </P>

<P> As we look at our application we'll go through several mental exercises to improve the application. </P>

<div class="todo"> these steps come from Rob Winch's awesome Packt book on Spring Security</div>
<ul>
    <LI>Segment users of the system into user classes</LI>
    <LI> Assign levels of authorization to user roles</LI>
    <LI>Assign user roles to user classes</LI>
    <LI>Apply authentication rules globally across application resources</LI>
    <LI> Apply authorization rules at all levels of the application architecture</LI>
    <LI>Prevent common types of attacks intended to manipulate or steal a user's session</LI>
</ul>
<h2> Using Spring Security to Secure Access to Our Web Application </h2>

<P> We'll use Spring Security. Spring Security makes short work of most of these concerns. We can easily <EM>adapt</EM>
    our system's notion of users to the common SPIs exposed by Spring Security. Once we've done this, Spring Security
    will happily provide a lot of services for us, including sign in functionality, sign out functionality, and support
    for protecting insecure resources. </P>

<h3> Introducing Spring Security in our Application </h3>

<P> Currently, all functionality for working users lives inside a service bean. This service bean (<span
        q="tut_security" class="class-reference" module="services">org.springsource.examples.spring31.services.UserService</span>)
    provides the ability to read, update and delete <code>user</code> data. It can also be used to authenticate that the
    user is who we think it is by taking a username and a password and searching for any users that have the given
    credentials. </p>

<P> Spring Security will need the ability to authenticate an identity given credentials to handle common functionality
    like the sign in and sign out forms. Our <COde>UserService</COde> can provide this functionality for our
    application, but we need to adapt it to Spring Security by implementing an interface, <SPAN module="spring-security"
                                                                                                class="class-reference">org.springframework.security.core.userdetails.UserDetailsService</SPAN>.
    <SPAN class="todo"> The full explanation of the <CODE>UserService</CODE> is beyond the scope of this text, but refer to the data access tutorial and the core tutorial</SPAN>.
    Let's focus on the implementation of <CODE>UserDetailsService</CODE>. First, the <CODE>loadUserByUsername</CODE>
    method: </P>

<div class="git-gist" gist="5226077"> loadUserByUsername(String username)</div>
<P> This method loads the record for the <CODE>User</CODE> from the database and then adapts it to the Spring Security
    <CODE class="class-reference">org.springframework.security.core.userdetails.UserDetails</CODE> contract, the
    implementation of which is as follows: </P>

<div class="git-gist" gist="5226079"> class CrmUserDetails { .. }</div>
<P>The <code>CrmUserDetails</code> implementation simply stores information about the user along with a few other pieces
    of hardcoded data used to satisfy the Spring Security contract. Broadly, this implementation can answer questions
    such as: </P>
<UL>
    <LI> What <EM>authorities</EM> does this user have? (can he make changes to the data, or can he only read data)</LI>
    <LI> What <EM>role</EM> does this user have? In our application the user is not further distinguished.</LI>
    <LI> What <EM>username</EM> does the user have? A username may change from system to system. There is no specific
        format, so long as the username uniquely identifies a record. In our system, the <EM>username</EM> is simply an
        alias for the email.
    </LI>
    <LI>What <EM>password</EM> does the user have?</LI>
    <LI> Is the user's account <EM>locked</EM>, or has it <EM>expired</EM>, requiring that access be revoked?</LI>
</UL>
<P>We can now use the <CODE>UserService</CODE> bean anywhere that Spring Security expects an implementation of <CODE>UserDetailsService</CODE>.
    Our <CODE>UserService</CODE> lives in the <CODE>services</CODE> module, and our <CODE class="class-reference"
                                                                                          module="web" q="tut_security">org.springsource.examples.spring31.web.config.WebMvcConfiguration</CODE>
    configuration class imports it when it imports <CODE class="class-reference" module="web" q="tut_security">org.springsource.examples.spring31.services.config.ServicesConfiguration</CODE>.
    The <code>id</code> of the bean is <CODE>userService</CODE>.
</P>

<P> As before when we configured Spring MVC, we want to customize the way Spring Security works a little, so we'll
    provide the definition for common objects in a new configuration class, <CODE class="class-reference"
                                                                                  q="tut_security" module="web">org.springsource.examples.spring31.web.config.SecurityConfiguration</CODE>,
    that will be loaded when the application starts up. It in turn imports security configuration defined in XML using
    the Spring Security XML namespace in a file called <CODE>security.xml</CODE>. For now, our configuration class is
    empty - just a standard configuration class.
 The XML file (<CODE>security.xml</CODE>) on the other hand will use the Spring Security XML namespace to handle securing our resources for us.

</p>

<div class="git-gist" gist="5226788"> public class SecurityConfiguration { ... }</div>
<h3> Securing Access to Resources </h3>

<P> A typical first step in securing an application is ensuring that requests to resources are secure, requiring
    authentication to succeed. To do this, we will use Spring Security's XML namespace to cordon off certain URLs from
    prying eyes. Here is the definition of first cut at <CODE>security.xml</CODE>, an XML file that uses the Spring
    Security namespace to secure resources. Let's examine some of the application URLs and examine which parts need to
    be secured. </P>
<TABLE>
    <thead>
    <TR>
        <th> URL Pattern</th>
        <th> Restrictions</th>
    </TR>
    </thead>
    <tr>
        <TD><CODE>/crm/profile.html</CODE></TD>
        <TD> All requests should only be made to a user that has authenticated and that has the <EM>authority</EM> of a
            user. Requests made by an <EM>anonymous</EM> or untrusted request will be shown the sign in form.
        </TD>
    </tr>
    <tr>
        <TD><CODE>/crm/customers.html</CODE></TD>
        <TD> All requests should only be made to a user that has authenticated and that has the <EM>authority</EM> of a
            user. Requests made by an <EM>anonymous</EM> or untrusted request will be shown the sign in form.
        </TD>
    </tr>
    <TR>
        <td><code>/**</code></TD>
        <TD> All <EM>anonymous</EM> requests to resources not otherwise protected by a rule defined above are permitted
            through.
        </TD>
    </TR>
</table>
<P> To implement these rules, we'll setup HTTP resource protection using the Spring Security XML namespace, as
    demonstrated below. </P>

<DIV class="git-gist" gist="5226793">
    <!-- <?xml version="1.0" encoding="UTF-8" ?> <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:sec="http://www.springframework.org/schema/security" xsi:schemaLocation="http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"> <sec:authentication-manager alias="authenticationManager"> <sec:authentication-provider user-service-ref="userService"/> </sec:authentication-manager> <sec:http use-expressions="true" auto-config="true"> <sec:anonymous enabled="true"/> <sec:intercept-url pattern="/crm/profile.html" access="hasRole('ROLE_USER')"/> <sec:intercept-url pattern="/crm/customers.html" access="hasRole('ROLE_USER')"/> <sec:intercept-url pattern="/**" access="isAnonymous()"/> <sec:form-login login-page="/crm/signin.html" default-target-url="/crm/profile.html" authentication-failure-url="/crm/signin.html?error=true"/> </sec:http> </beans>--> </DIV>
<p> The first thing that you notice is that we've used the <code>sec:authentication-manager</code> element to define an
    instance of <CODE module="spring-security" class="class-reference">org.springframework.security.authentication.AuthenticationManager</code>,
    which in turn delegates to configured instances of <CODE module="spring-security" class="class-reference">org.springframework.security.authentication.AuthenticationProvider</CODE>.
    As configured, Spring Security will create an <CODE>AuthenticationProvider</CODE> which delegates to our <CODE>userService</CODE>
    bean. The <Code>AuthenticationManager</Code> is used by practically <EM>everything</EM> in the Spring Security
    framework, in one way or another, so get in the habit of setting this element up whenever you start with Spring
    Security. </p>

<P> Next up, we define a <CODE>http</CODE> stanza, which helps define rules for access to HTTP resources. We tell it
    that we want to use the Spring Expression Language expressions in our configuration by enabling the <CODE>use-expressions</CODE>
    attribute. By setting the <CODE>auto-config</CODE> attribute to true, we automatically enable several niceties,
    including: </P>
<UL>
    <li><B>a login form</B> Specifically, Spring Security exposes an endpoint that can handle authentication of a
        username and password from a form of our own design. If the authentication is successful, Spring Security will
        persist the user's <CODE>authentication</CODE> in the HTTP session where other Spring Security related
        functionality will know to find it.
    </li>
    <LI><B>anonymous authentication</B> Some resources can be accessed by so-called <EM>anonymous</EM> users, or users
        that have made requests of the web site without being signed in.
    </LI>
    <LI><B>logout services</B> An HTTP endpoint that when invoked will clear the session of any user <CODE>authentication</CODE>
        information, which should have the effect of disabling all the functionality that's protected by Spring Security
        checks for a valid user.
    </LI>
    <LI><B>remember-me support</B> Spring Security can persist (using an HTTP cookie) and pre-fill a username in the
        sign in form, necessitating only that the password be entered. This is a convenience to spare users from having
        to constantly remember a username.
    </LI>
    <li><B>basic authentication</B> Spring Security will respond to, and handle, requests made using HTTP <CODE
            class="wikipedia">Basic access authentication</CODE>.
    </li>
</UL>
<P> Inside of our XML <CODE>http</CODE> stanza, we first enable <CODE>anonymous</CODE> access using the <CODE>sec:anonymous</CODE>
    element. Then, using the <CODE>sec:intercept-url</CODE> element, we declaratively restrict access to certain URLs.
    The conditions upon which access are granted are specified by the <CODE>access</CODE> attribute, which in this case
    is evaluating method calls against an instance of <CODE class="class-reference" module="spring-security">org.springframework.security.access.expression.SecurityExpressionRoot</CODE>,
    which can answer questions about the authentication in the current request: is the request <EM>anonymous</EM>; does
    the request come from someone who has been authenticated? </P>

<P> Finally, we establish that we want Spring Security to handle HTTP sign in requests for us using the <Code>sec:form-login</Code>
    element. We specify which page a user (<CODE>/crm/signin.html</CODE>) should be presented with when accessing a
    resource to which the user does not currently have access. We specify the URL to which a successfully authenticated
    user is redirected after authentication (<CODE>/crm/profile.html</CODE>) and then we specify what resource (<CODE>/crm/signin.html?error=true</code>)
    should be displayed when there is an error attempting to sign in. Now, should any one attempt to access a resource
    that requires an authenticated user, Spring Security will redirect the request to the sign in form. Let's look a
    little deeper at Spring Security's support for sign in forms. </P>

<H3> Re-Building Our Sign In Functionality </H3>

<p> Earlier, we built a form to handle signing in. The sign in form had a few text fields and submitted values to the
    server where a Spring MVC controller received the values, attempted to find a match in the database for the
    specified username and password, and then stored the authenticated user in a freshly created HTTP session. From the
    client side, the only thing of note was that we named our HTML <CODE>input</CODE> fields and those names had to
    match server request parameters expected in the Spring MVC controller. While it was relatively easy, it's still
    something that you'll find yourself re-creating a lot over various applications. Instead </p>

<P> We can simply remove the <CODE class="class-reference" q="tut_security" module="web">org.springsource.examples.spring31.web.ViewController</CODE>
    class as we won't need it to handle the sign in. We also need to change our <Code>signin.jsp</Code> a little bit to
    embrace the support Spring Security provides. Here's the reworked <CODE>signin.jsp</CODE> that simply detects the
    presence of the error variable in the request and presents feedback accordingly. This is different from the previous
    version because it doesn't enumerate errors. </P>

<div module="web" q="tut_security" class="git-code" extension="jsp"> src/main/webapp/WEB-INF/views/signin/signin.jsp
</div>
<H3> Displaying Dynamic Menu Options for Authenticated Users </H3>

<P> Earlier, in our <CODE>/WEB-INF/layouts/template.jsp</CODE> code we simply tested for the <CODE>user</CODE> object in
    our HTTP session. We'll replace that test with the Spring Security JSP tag library. In particular, we'll use Spring
    Security tags to check access using the same expressions that we used in our earlier configuration of the various
    HTTP resources. We can also finally provide a URL for the sign out link in our navigation. In this example we use a
    JSP snippet (<code>&lt;c:url value="/j_spring_security_logout" var="logoutUrl"/&gt;</code>) to calculate the context
    root for the URL that Spring Security provides to handle sign out requests. The resulting value is stored as a page
    attribute under the name <CODE>logoutUrl</CODE>, which is substituted into the <CODE>href</CODE> attribute for the
    sign out URL. </P>

<DIV class="git-gist" gist="5230487"> spring security tags</DIV>
<h2> Using Spring Security OAuth to Secure Access to our REST API </h2>

<p> Thus far, we've secured all access to our web application, but <EM>not</EM> the RESTful endpoints. A natural first
    step might be to secure the endpoints from access using the <CODE>http</CODE> elements in our Spring Security XML
    configuration. This would certainly restrict access, but would oblige the client of the REST endpoints to sign in
    using the HTML form. This would trigger the creation of an HTTP session that the client would need to perpetuate.
    The client would need to transmit some piece of data that the server could use to correlate the client requests to
    the session on the server. Typically, this is the <CODE>JSESSIONID</CODE> cookie. At the very least, such an
    approach would require the client to use the same HTTP endpoints as the sign in form, and somehow work with the same
    error validation feedback loop generated by the HTML form. </p>

<P> Let's consider the use cases for our REST endpoints. We know that we want to be able to use the REST APIs from
    processes running outside the application: browser-based JavaScript code, applications running on phone or tablets,
    perhaps a desktop application. </P>

<P> If you think about it, this sort of arrangement is very common. For example, each time you install a game on
    Facebook which may or may not
    post on your wall and invite others to join you, that game is using your Facebook data on your behalf. Each time you
    trust another website to
    authenticate you using your Facebook data ("Sign In With Facebook"), you're entrusting that application to use your
    Facebook data on your behalf.
</P>

<P> There are a lot of ways we might imagine developing such a solution for our own application.
    One approach might be to expose a RESTful API for <EM>signing in</EM> a user with a username and password. This
    strategy has a few flaws, however.
    First, it's common security practice to prompt users to change passwords at a frequent interval - perhaps every few
    months. This would immediately break any
    clients accessing the API on your behalf as their cached password would be invalid.
    If you trust a client, then you probably don't expect it to stop working each time you change your password.</p>

<P>
    When we use a client running out of process - be it a third party
    application or simply an application running in another process and over the network, we establish that we trust the
    client to
    work with our data, but this does not necessarily mean we trust the client with our password.
    A password's a far more sensitive matter. In the worst case, a password might be the same for a user across multiple
    services. This is bad security practice, of course,
    but it's still very common. Just because you trust one client to access your Facebook data, for example, that does
    not mean you trust it to access your email on GMail, or your photos on Flickr.
    Some services are less
    scrupulous than others.

    Let's suppose the user entrusted his or her password with an errant, malicious application. Let's suppose the client
    immediately changes the password,
    effectively hijacking the user's account. What recourse does that user - now locked out of his account - have?
</P>
<P> If the user did decide to revoke permissions to the client, she would have to change the password, effectively breaking all the other clients <EM>and</EM> forcing
    the user to remember a <EM>new</EM> password.
</P>
<P>
    Finally, such a scheme is hard to protect against man-in-the-middle attacks unless we specifically request, and
    verify, that all clients transmit authentication credentials over something like SSL, which is tedious at best.
</P>

<h3>Introducing OAuth
</h3>

<div class="diagram"><img src="images/oauth.png" style="width: 300px"/> <span class="caption"> The OAuth logo</span></div>
<P>
    Clearly, we can do better. One very common approach employed by Facebook, Twitter, GitHub, Google+, LinkedIn and
    innumerable many other service providers is <span class="wikipedia">OAuth</span>.
    OAuth prescribes the following basic flow of interaction between a user, a client, and a service provider like Facebook:
</P>


<OL>
    <LI>
        The client - intending to act on the user's behalf - requests certain permissions from a service provider's API for a given user.
    </LI>
    <LI> The client   then prompts the user to authorize these permissions by redirecting to a page on the service providers known, trusted, secured, website.
        If there user is not currently authenticated and does not have a valid session,
        the user signs in (again, on the service providers web site where care can
        be taken to secure the transport of the credentials between the user and the service provider).

    </LI>
    <LI>
       Once the user is signed in, he or she is prompted to authorize certain permissions ("Read my profile information," "update my profile photo," "post to my wall," "Tweet on my behalf," etc.)
    </LI>
    <LI>
     If the user authorizes the permissions, the service provider  redirects <EM>back</EM> to the client's HTTP endpoint, transmitting with it an <CODE>access token</CODE>, perhaps as part of the request parameters,
        or as part of the URL query (the part of the URL after the "<EM>#</EM>" character).
    </LI>
    <LI> The client keeps the access token and transmits it on each subsequent request.
    </LI>
</OL>
<div class="todo"> Insert a  sequence diagram here
</div>


<P>

    The result of this process is that the client is left with a password that is still secret.
    Access for individual clients may be revoked independent of each other by simply invalidating individual access tokens.
    The user may change the password without breaking clients  since they will just use the access token.
    As the user only transmits a password on the service providers domain, the security and integrity of the credentials may be ensured.
    Not bad, right?
</P>
<h3> Adding Spring Security OAuth to our Application
</h3>
<!--
Steps for SS OAuth :
 * add the clientuserdetails api
 * add OAuth endpoints to handle the various coordination calls
 * secure the OAuth endpoints
 *

-->
<P>
    connect the client
</P>
<a name="eof"></a></body>
</html>