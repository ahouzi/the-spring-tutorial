<html xmlns="http://www.w3.org/1999/html" xmlns="http: //www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html"
      xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html"
      xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head><title>The Spring Tutorial: Web </title>
    <!-- todo jquery logic to make all class-reference spans links to the javadocs for the code todo jquery logic to make all wikipedia spans links to the wikipedia entry for the text therein. -->
    <style type="text/css"> .todo {
        color: red;
    }

    .wikipedia {
    }

    .diagram {
        width: 500px;
    }

    table, th, td, th {
        vertical-align: top;
    }

    .diagram img {
        width: 500px;
    }

    .caption {
        font-style: italic;
        font-size: smaller;
        display: block;
    }

    code, .git-code, .git-gist, .class-reference {
        font-family: courier, monospace;
        font-size: smaller; /* background-color: #dcdcdc;*/
    } </style>
    <script type="text/javascript" lang="javascript"> var StringUtils = { a: function (label, url) {
        return '<a href="' + url + '">' + label + '</a>';
    }, code: function (inp) {
        var lt = '<', gt = '>';
        while (inp.indexOf(lt) != -1) {
            inp = inp.replace(lt, '&lt;');
        }
        while (inp.indexOf(gt) != -1) {
            inp = inp.replace(gt, '&gt;');
        }
        return "<PRE><CODE>" + inp + "</CODE></PRE>";
    }, encodeFullyQualifiedPath: function (ref) {
        var url = ref;
        while (url.indexOf('.') != -1) {
            url = url.replace('.', '/');
        }
        return url;
    }, classForFullyQualifiedClass: function (ref) {
        var lastPeriod = ref.lastIndexOf('.');
        if (lastPeriod == -1) return ref;
        return ref.substring(lastPeriod + 1);
    }}; </script>
    <script src="js/jquery-1.8.3.min.js"></script>
    <script src="js/github-files.js"></script>
    <script src="js/tutorial.js"></script>
</head>
<body>

<h1>Welcome</h1>

<P> In this tutorial we will show you how to do these things with Spring MVC:</p>
<uL>
    <LI> Create a working web application</LI>
    <LI> Handle form submissions</LI>
    <LI> Build a screen to handle CRUD, (create, read, update, and delete)</LI>
    <LI>
        Separate UI and Data Model via RESTful Web Services
    </LI>
    <LI> Learn how to secure your application (sign-in, and sign-out support)</LI>
    <LI> Learn how to secure your REST services with OAuth</LI>
    <LI> Learn how to connect your application to Social Service providers like Facebook</LI>

</uL>

<!-- todo Who is this document for?
-->
<h2>
    Who Is This Document For?
</h2>

<P>
    Presumbly you've learned Java, but want to learn about web programming in Java, and you've got a good grasp
    on the core concepts of Spring. For more, please consult the Green Beans blogs and the core Spring tutorial as part
    of
    this set of tutorials.


</P>


<h2> Tools </h2>

<P> Let's build a simple web application to see how the moving parts fit together. Our application will be a simple
    Customer Relationship manager (CRM) of sorts. Users can create an account, login and then manage simple customer
    records. We already have Hibernate-based backend services that manage user (<span module="services" q="tut_web"
                                                                                      class="class-reference">org.springsource.examples.spring31.services.UserService</span>)
    and customer (<span module="services" q="tut_web" class="class-reference">org.springsource.examples.spring31.services.CustomerService</span>)
    data for us.</p>

<P> We're using <A href="http://maven.apache.org">the Apache Maven</A> build tool to include those classes in our web
    application. <SPAN class="todo">To learn more about how to assemble basic service objects with the Spring framework please see our introduction tutorial.</SPAN>
    To learn more about working <A
            href="http://blog.springsource.org/2011/01/17/green-beans-getting-started-with-maven-and-spring/">with
        Apache Maven and Spring, see this blog post</a>. Maven requires a basic directory structure for all modules in a
    given Maven project. The structure looks like this: </p> <span class="git-gist" gist="4947010">https://gist.github.com/joshlong/4947010</span>

<P> Our project has two modules, <CODE>services</CODE> and <CODE>web</CODE>. <CODE>services</CODE> exports a services
    API. The services API is your basic service tier using PostgreSQL and Spring's support for JPA. We won't say much
    more about it beyond that except that it handles manipulating data in terms of the <CODE></CODE></P>

<P> TODO we need to show them how to setup the database and the sample application Check out the data tutorial for
    details on data access with Spring. For a complete step by step introduction opn how to setup the sample application
    please refer to the <CODE>README</CODE>. </P>

<h3> Setting Up the Tool Chain </h3>

<P><SPAN class="todo"> show how to import the code and where to get it and how to use STS File &gt; Import and how Maven helps us. Our tutorial is tool agnostic, but we recommend the free STS edition which comes wiht all sorts nice utilities </SPAN>
</P>

<P> Also: maven has a certain build structure. </P>


<h1> Basic Web Applications with Spring
</h1>


<p> The original code in Spring was written to support the web. Indeed, the earliest classes (like, <span
        module="spring-web" q="tut_web"
        class="class-reference">org.springframework.web.context.WebApplicationContext</span>) that Spring founder Rod
    Johnson wrote in his study in England in 2001 were to support Java-based web applications environments. Spring's
    always had a great support for the web. From the beginning, Spring has featured an MVC framework, called Spring MVC.
    Spring MVC at the time looked conceptually very similar to the then entrenched Struts framework. While Spring MVC
    evolved on its own merits, Spring did everything possible to ease the lives of developers using other web
    frameworks, like Struts. The Spring-Struts integration support in the core Spring web modules made Struts a much
    nicer proposition for developers who were stuck using Struts, but wanted a cleaner, POJO-centric component model.
    <!--todo link to what Spring Web Flow is; assume the n00bs don't know -->Indeed, Springs JSF integration for 1.0 and
    2.0, as well as the JSF-centric Spring Web Flow, offer drastically improved user experiences for developers stuck on
    those web frameworks. While Struts is largely a distant memory, and JSF is fast-becoming one, Spring MVC has emerged
    as, and remained, the most popular Java web framework in the world. </p>

<P> There are a lot of reasons for this, but I think it's because Spring MVC has <EM>embraced</EM> the web, not
    attempted to hide developers from it. Indeed, if Spring MVC can be said to <EM>hide</EM> anything, it is the
    complexities of building scalable Servlet-based applications, <EM>not</EM> the web. </P>

<P> Conceptually, web programming is simple: HTTP requests come in, and responses are created and sent in response. No
    state is retained in between requests on either the server or the client, by default. This can be deceptively
    simple. As requests come in, they invariably are handled by some component that acts on them, and is then charged
    with sending a response. A response, in the common case, is some sort of HTML-based page. Unfortunately, there's
    often a disconnect between effective handling of requests (and tying those requests to the appropriate back-end
    business logic) and rendering of nice responses. Put another way, programmers are rarely good user-interface
    designers. So, a separation of the two domains - business logic and server-side handling from designing and
    rendering rich interactive user interfaces - is often necessary. This way, programmers can work on the part that
    matters most to them - the business logic - and the Adobe Dreamweaver-toting designers can focus on the styling and
    design of the user interface. To keep programming applications that behave in this way simpler, programmers have
    adopted a variant of the popular <span class="wikipedia">model-view-controller</span> (MVC) pattern called <span
            id="model2mvc" class="wikipedia">Model_2</span> MVC. This pattern is best visually described like this: </P>

<div class="diagram"><img src="images/model 2 mvc.png"/> <span class="caption"> The Model-2 MVC pattern </span></div>
<P> As HTTP requests come in, they're routed to the <EM>front controller</EM> - the <span module="spring-web"
                                                                                          class="class-reference">org.springframework.web.servlet.DispatcherServlet</span>
    in Spring MVC - which then selects from among the registered <EM>controller</EM> classes and chooses the right one
    to handle the HTTP request. There needs to be some stipulation between the <EM>front controller</EM> and the
    registered controllers as to which controller should handle which request. When the controller is activated, it is
    given access to all the data about the request and it can react accordingly. Once the request is handled, the
    controller must somehow signal that a response should be rendered. Typically, this means telling the framework which
    <EM>view</EM>, or <EM>response</EM>, to render. A view might be a designer-provided template that merges data into
    itself and then renders as HTML. The response might also be something constructed in code in the controller, like
    file data or the binary data for a PDF or spreadsheet. </P>

<h2> Configuring a Servlet 3.0 Container for our Application</h2>

<p> Working with Spring MVC is <EM>very</EM> straightforward! If you're using a Servlet 3.0 container like the market
    and segment-leading <A href="http://tomcat.apache.org">Apache Tomcat 7</A>, then it's even easier! Our initial Java
    web application consists of three classes - <span module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer</span>,
    <span module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.config.WebMvcConfiguration</span>,
    and <span module="web" q="tut_web"
              class="class-reference">org.springsource.examples.spring31.web.ViewController</span> - and several
    artifacts to generate the HTML views. Let's look at these classes. </p>

<P> <!-- todo rewrite this to reflect --> To work with any web framework, like Spring MVC, you need to install the
    various Servlet components using a deployment descriptor (<code>web.xml</code>) or, alternatively, in Servlet 3
    environments, a Java initializer class. Ours will be a Java Servlet 3.0-compatible web application. Servlet 3.0
    applications run in any web container that supports Servlet 3.0, including Apache Tomcat 7. You can use Spring in
    containers that support earlier versions of the Servlet specification, however some Servlet 3.0-specific
    capabilities - such as Java-based initializer classes and features designed to support asynchronous responses won't
    work in those environments. We'll mention the Servlet 3.0 specific bits as we encounter them. </p>

<P> The Servlet environment provides a few low level class types that can be used in building web applications. Here are
    some of the types of classes that we need to be aware of. </P>
<OL>
    <LI><B>Servlets</B> - objects of type <CODE module="servlets" class="class-reference">javax.servlet.Servlet</code>
        that are given a chance to act on incoming HTTP requests and produce replies. This is the most common type of
        component. <CODE>Servlet</CODE>s are mapped to the URLs that they will respond to by a type of pattern.
    </LI>
    <LI><B>Listener</B> - objects of type <CODE module="servlets" class="class-reference">java.util.EventListener</CODE>
        - typically of a Servlet-speciifc subclass like <CODE module="servlets" class="class-reference">javax.servlet.ServletContextListener</CODE>
        or <CODE module="servlets" class="class-reference">javax.servlet.http.HttpSessionAttributeListener</CODE>. These
        classes are notified of various events in the web application such as the creation of data stored in memory, the
        changes in the Servlet container itself, or changes in one of the Servlets managed by a web application
        container.
    </LI>
    <LI><B>Filters</B> - objects of type <CODE module="servlets" class="class-reference">javax.servlet.Filter</CODE>
        that are given a chance to act on, or possibly change, incoming HTTP requests before they are routed to the
        <CODE module="servlets" class="class-reference">javax.servlet.Servlet</CODE>s to which they've been routed and
        all outbound HTTP replies produced by those <CODE>Servlets</CODE>. This is useful in many scenarios - such as
        processing security on all requests, or handling things like GZip compression.
    </LI>
</OL>
<P> Unfortunately, the Servlet environment itself is devoid of most of the basics that any modern web application will
    need. Fortunately, Spring provides these building blocks, letting you assemble them as you like, and letting you
    focus on the task at hand: the business of your application. Here is our Java-based application initializer which
    installs Spring's Servlet infrastructure classes to support our application. If you're familiar with Java Servlets,
    then you'll recognize this as a Java code-only replacement or substitute for <CODE>web.xml</CODE>, an XML-based
    deployment descriptor. </P>

<div class="walkthrough">
    <div module="web" q="tut_web" extension="java" class="git-code">
        org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer
    </div>
    <div><P> The class implements the Spring interface, <span class="class-reference" module="spring-web">org.springframework.web.WebApplicationInitializer</span>.
        which provides a callback method <CODE>void onStartup(ServletContext servletContext) throws
            ServletException</CODE>. This method is called as the application is started by the application container,
        providing a reference to the current <CODE>ServletContext</CODE> which in turn can be used to programmatically
        construct the various Spring MVC framework components. </P>

        <P> This code does two things. It registers a <CODE module="spring-web" class="class-reference">org.springframework.web.context.ContextLoaderListener</code>
            that in turn instantaites our Spring <CODE class="class-reference" module="spring-context">org.springframework.context.ApplicationContext</CODE>
            implementation (<code class="class-reference" q="tut_web" module="web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</code>)
            and makes it available to the entire application and all the Servlet components we register. </p>

        <P> Next, we register the <code class="class-reference" module="spring-webmvc">org.springframework.web.servlet.DispatcherServlet</code>.
            This is the class that Spring provides to handle all incoming HTTP requests (the aforementioned <EM>front
                controller</EM>), routing them to the correct <EM>controllers</EM> and working with the other parts of
            the framework to handle common use cases for us. The <CODE>DispatcherServlet</CODE> can manage its own
            <CODE>ApplicationContext</CODE> as well as see and work with the <COde>ApplicationContext</COde> instances
            that the <CODE>ContextLoaderListener</CODE> creates. The <CODE>DispatcherServlet</CODE>'s <CODE>ApplicationContext</CODE>
            is said to be <EM>parented</EM> by the <CODE>ContextLoaderListener</CODE> <CODE>ApplicationContext</CODE>.
            You could, for example, register different <CODE>DispatcherServlet</CODE> instances for different parts of
            the application, and they could share beans in the <EM>parent</EM> <CODE>ApplicationContext</CODE> managed
            by the <CODE>ContextLoaderListener</CODE>. </p>

        <P> As we're running in a Servlet 3 environment, and want to take advantage of <EM>asynchronous</EM> Spring MVC
            controllers, this code activates <EM>async</EM> support on all components where appropriate by calling
            <CODE>setAsync(true)</CODE>. Since we want Spring MVC to have control over the entire application, this code
            <EM>maps</EM> all components to <CODE>/*</CODE> where possible. This means that <EM>all</EM> requests will
            be handled by Spring MVC. We can later specialize our routing from within Spring MVC, of course. </P></div>
</div>
<h2> Configuring Spring MVC </h2>

<h3> The Simplest Possible Spring MVC Application
</h3>

<P> Once we've told the Servlet environment everything it needs to know (for now), we simply need to turn on Spring MVC
    and tailor it based on our application requirements. To get a working, reasonably configured installation of Spring
    MVC, you simply need to add <CODE module="spring-webmvc" class="class-reference">org.springframework.web.servlet.config.annotation.EnableWebMvc</CODE>
    to a Java configuration class that the previously installed <CODE>ContextLoaderListener</CODE> imports. </p>

<div class="git-gist" gist="4726096"> @Configuration @EnableWebMvc public class WebMvcConfiguration {}</div>
<P> By default, this will activate many things based on conventions and the availability of certain libraries on the
    class path. Some of the things supported out of the box: </P>
<uL>
    <LI> The Spring MVC <CODE class="class-reference"
                              module="spring-context">org.springframework.stereotype.Controller</CODE>-annotation based
        component model is turned on. All Spring beans annotated with this stereotype annotation will automatically be
        processed and exported as HTTP handlers. If your application is running in a Servlet 3 environment, then <EM>asynchronous</EM>
        controllers are supported as well.
    </LI>
    <LI> File upload support through the <A href="http://commons.apache.org/proper/commons-fileupload//">Apache Commons
        FileUpload library </A> (if detected on the class path) or via the Servlet 3 <CODE class="class-reference"
                                                                                           module="servlets">javax.servlet.http.Part</CODE>
        API.
    </LI>
    <LI> REST and JSON and XML marshaling support if the <A href="http://jackson.codehaus.org/"> Jackson JSON-Object
        marshaling library</A> or <A href="http://jaxb.java.net/tutorial/">a JAXB implementation</A> is on the class
        path.
    </LI>
    <LI>Bean and form validation if <A href="http://beanvalidation.org/1.0/spec/">a JSR 303</A> implementation <a
            href="http://www.hibernate.org/subprojects/validator.html">like Hibernate Validator</a> is on the classpath.
    </LI>
</uL>
<p> We can do a lot with this simple setup! There's one thing missing, however. As configured, Spring MVC doesn't render
    views in a useful way and it doesn't know about your controllers. You can use the standard Spring annotation
    <CODE class="class-reference" module="spring-context">org.springframework.context.annotation.ComponentScan</CODE>
    annotation to tell Spring to automatically register your data services (Spring beans that handle our data-access
    logic) and your Spring MVC controllers (beans annotated with the <CODE class="class-reference"
                                                                           module="spring-context">org.springframework.stereotype.Controller</CODE>
    annotation) by scanning all the beans in or below the package, or packages, specified. You can specify these
    packages
    either as a String or by specifying a class that lives in the package you want to scan. The latter approach is more
    refactor-friendly: if you change the package structure of your code, your tooling will update references to classes,
    but might not necessarily refactor Strings that contain a package path. </p>

<P> As depicted in the diagram above, Spring MVC will <EM>resolve</EM> a <EM>view</EM> based on some heuristic
    supplied by a registered implementation of <span class="class-reference" module="spring-webmvc">org.springframework.web.servlet.ViewResolver</span>.
    Let's install a very basic implementation ( <span class="class-reference" module="spring-webmvc">org.springframework.web.servlet.view.InternalResourceViewResolver</span>)
    that will render local <CODE>.jsp</code> pages. </p>

<div class="git-gist" gist="5067119"> @Bean public InternalResourveViewResolver(){ ... }</div>
<P> With this in place, Spring MVC will take a view String (say, <CODE>"hi"</CODE>) and resolve it to <CODE>WEB-INF/hi.jsp</CODE>,
    which it will then load and send back to the client, rendered with any data communicated through the
    <CODE>Model</code> object.
    Let's pause, do a sanity check, and take a moment to deploy a Spring MVC controller complete with a working view.
    First, add your <CODE>.jsp</CODE> page (<CODE>WEB-INF/hi.jsp</CODE>): </p>

<DIV class="git-gist" gist="5067085"> some jsp content</DIV>

<p> Now, let's create a simple Spring MVC controller. We'll look at that the composition of the controller later,
    instead preferring to verify that everything's working now.
    Add the following class: </p>

<div class="git-gist" gist="5067155"> @Controller HelloWorldController</div>

<P> Then simply build this and deploy to your application server.
    <!-- TODO link to the beginning of this tutorial If you're using the Spring Tool Suite, you simply need to deploy the application to Apache Tomcat in your <CODE>Servers</code> panel.
    -->
    You should be able to bring up the page like this: </P>

<div class="diagram"><IMG src="images/hello-world-controller.png"/> <span class="caption"> Change the <CODE>name</CODE> attribute to whatever you like to change the name printed. If the name query parameter is not present, the code will simply default to printing "World." </span>
</div>
<h2>
    Building the Screens for Our Application
</h2>

<P> While the default configuration gives you a lot out of the box, we will tailor the code a little bit to support our
    application's specific requirements. Most of what we will configure in Spring MVC has to do with customizing how
    Spring MVC renders templates for pages. to understand these use cases better, let's look at the pages and screens we
    know we will need to support. </P>
<TABLE width="600">
    <thead>
    <TR>
        <th> Page</th>
        <th> Preview of Page</th>
        <th> Description</th>
    </TR>
    </thead>
    <tr>
        <td><b> signin</b></td>
        <TD><img width="300" src="images/signin.png"/></TD>
        <td> a page where users can sign in. This should be the home page users are greeted with when they visit the
            application for the first time (under <CODE>/*</CODE>).
        </td>
    </tr>
    <tr>
        <td><b>signup</b></td>
        <TD><img width="300" src="images/signup.png"/></TD>
        <td> users should be able to sign up for a new account and potentially register via FaceBook</td>
    </tr>
    <!-- <tr> <td><b> oops </b></td> <TD><img width="300" src="images/oops.png"/></TD> <td> this is the page to show when ever there is an error in the system. Maybe the user accesses the wrong page and needs to be given a 404, or perhaps the system throws some sort of awful as-yet-uknown error. Handling this gracefully is a mark of polish. </td> </tr>-->
    <tr>
        <td><b> profile </b></td>
        <TD><img width="300" src="images/profile.png"/></TD>
        <td> there needs to be some place where users can update their profile information like their password and other
            features (like a profile photo?).
        </td>
    </tr>
    <tr>
        <td><b>customers </b></td>
        <TD><img width="300" src="images/customers.png"/></TD>
        <td>there should of course be a screen to work with data related to customers.</td>
    </tr>
</TABLE>
<h3> Handling Page Layouts with Apache Tiles </h3>

<P><img src="http://tiles.apache.org/images/powered-by-tiles.png" width="200" style="float:left ; margin-right: 20px;"/>
    Building individual web pages is easy. Simply slap together some HTML and then you're set. Building web applications
    well, on the other hand, is an entirely different thing. Well built web applications are visually consistent, often
    sharing consistent styling and theme and layout cues across all pages in the application. <A
            href="http://tiles.apache.org/">Apache Tiles</a> is a very common templating engine. Apache Tiles lets you
    extract <EM>the things that stay the same from the things that change</EM>, in other words: it lets you define a
    template and then - on a page by page basis - change or override the definition for individual parts (or
    <EM>tile</eM>s) of the template without re-specifying the template over and over. </p>
<!--install tiles in Spring --> <P> To enable Apache Tiles for your application, you simply add the following two <CODE>@Bean</CODE>
    definitions to your <CODE>@Configuration</CODE> class above. (Be sure to remove the existing <span
            class="class-reference" module="spring-webmvc">org.springframework.web.servlet.view.InternalResourceViewResolver</span>)
</P>

<div class="git-gist" gist="5059411"> @Bean UrlBasedViewResolver @Bean TilesConfigurer</div>
<P> Apache Tiles has a lot of moving pieces that need to be installed, but Spring can handle all of this for you with
    the <CODE class="class-reference"
              module="spring-webmvc">org.springframework.web.servlet.view.tiles2.TilesConfigurer</CODE>. Recall that
    Spring MVC delegates to <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.ViewResolver</CODE>
    instances to translate strings like <CODE>home</CODE> to an appropriate view template. The <code
            module="spring-webmvc"
            class="class-reference">org.springframework.web.servlet.view.tiles2.TilesViewResolver</code> resolves the
    appropriate Tiles definitions. </P> <!-- then look at a page --> <P> If you look at the swath of screen shots above,
    it's not hard to identify the common elements in our page layouts. In the diagram below, I've drawn colored boxes
    over the parts of the page that could be expected to change. </P>

<div class="diagram"><IMG src="images/signin-tiles.png"/> <span class="caption"> A typical layout divided into its constituent "tiles" </span>
</div>
<P> The page has a header - the band in yellow, a body - the band in green, and a footer - the band in blue. The header
    and footer might have slightly dynamic behavior based on whether someone is logged in or not, but we can expect that
    they'll always be there, so they can be put in the base template definition - the one shared with <EM>all</EM>
    pages. The only thing that will change on a page-by-page basis is the <code>body</code>. Let's look at the
    definition of the base template in Tiles' configuration format. Apache Tiles expects information about the templates
    to be provided in the form of an XML file, called <CODE>tiles.xml</code>. Apache Tiles supports template
    inheritance. You might specify a base definition to be shared as the basis for other templates like this file
    (<CODE>web/src/main/webapp/WEB-INF/layouts/tiles.xml</CODE>): </P>

<div module="web" q="tut_web" extension="xml" class="git-code"> src/main/webapp/WEB-INF/layouts/tiles.xml</div>
<P> This specifies a <CODE>&lt;definition&gt;</CODE> (named <strong><CODE>page</code></strong>) that in turn specifies a
    template to render (the file <CODE>/WEB-INF/layouts/template.jsp</CODE>). The template has regions that are to be
    substituted for actual content or values at render time. </P>

<div class="git-gist" gist="4948600"> html html [tiles:.. ] ...</div>
<P> I've omitted most of the content from this page including the JavaScript and CSS declarations and left only the
    skeletal structure in the example above. In particular, you'll note that we've specified a <CODE>&lt;tiles:insertAttribute&gt;</CODE>
    tag that will attempt to substitute whatever template or value is provided for the region named <EM>content</EM>. If
    you're looking at the <CODE>template.xml</CODE> declaration above, you may be wondering where we specify which
    content is to be substituted into the <EM>content</EM> region. We specify this in each <CODE>tiles.xml</CODE>
    definition that <EM>extends</EM> this root <CODE>tiles.xml</CODE> for each screen. </P>

<p> With this structure in place, it's easy to iterate on new pages as we only have to concern ourselves with the UI
    elements unique to the page in question. For each page, we need to specify a <CODE>tiles.xml</CODE> file that <EM>extends</EM>
    the base <code>tiles.xml</code>. Let's look at the configuration for the <CODE>tiles.xml</CODE> for our signin page,
    <CODE>src/main/webapp/WEB-INF/views/signin/signin.jsp </CODE>. </p>

<div module="web" q="tut_web" extension="jsp" class="git-code"> src/main/webapp/WEB-INF/views/signin/tiles.xml</div>
<P> This definition (named <strong><code>signin</code></strong>) extends <CODE>page</CODE>, defined above. It specifies
    the content to be placed in the <CODE>content</CODE> tile from the base definition. The structure of our views looks
    like this: </P>

<div class="diagram"><IMG src="images/tiles-hierarchy.png"/> <span class="caption"> The <EM>root</EM> Tiles definition lives in <CODE>WEB-INF/layouts/tiles.xml</CODE>, but the individual pages live in <CODE>WEB-INF/views/*/tiles.xml</CODE>. This organizational structure is reflected in the configuration for Apache Tiles in the <CODE
        class="class-reference"
        module="spring-webmvc">org.springframework.web.servlet.view.tiles2.TilesConfigurer</CODE> above. </span></div>
<P> Now, when a Spring MVC controller returns <CODE>"signin"</CODE>, the Tiles view definition named <CODE>signin</CODE>
    will be loaded and rendered. </P>

<h3>Rendering Resources with the Default Servlet </h3>

<P> Our application already has a lot going for it, but we're not done. You'll recall from our configuration in <span
        module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer</span>,
    that we <EM>mapped</EM> the Spring <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.DispatcherServlet</CODE>
    to <CODE>/*</CODE>. <EM>All</EM> requests going to this application will be routed to the Spring MVC <CODE>DispatcherServlet</CODE>
    with this configuration. There, the <CODE>DispatcherServlet</CODE> will look for a Spring bean annotated with <COde>@Configuration</COde>
    to handle the request. What happens if the request isn't handled by a <CODE>@Controller</CODE>-annotated bean? What
    then? What, for example, handles requests for <CODE>*.js</CODE> and <CODE>*.css</CODE> resources? </p>

<P> Normally, if no Servlet was mapped to handle a request, the <EM>default</EM> or <EM>file</EM> Servlet provided by
    the Servlet container handles it. This <EM>default</EM> Servlet's pre-built, usually optimized for rendering
    resources out of the web application, and very fast. As we configured Spring MVC to handle <EM>all</EM> requests,
    however, we lose the services of this <EM>default</EM> Servlet. Fortunately, with Spring MVC we can have our cake
    and eat it too! </p>

<P> Spring MVC has a lot of functionality that you can override, or enable/disable, by implementing the interface <CODE
        class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.WebMvcConfigurer</CODE>.
    There are a <EM>lot</EM> of callback methods in this class that you can implement that give you the opportunity to
    specify a lot of Spring MVC's behavior. To keep our code cleaner and avoid implementing a lot of methods we don't
    care about, <code class="class-reference" module="web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</code>
    will extend <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter</CODE>,
    which implements <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.WebMvcConfigurer</CODE>
    with empty no-op methods. </P>

<P> To handle the resources with no mapped <CODE>Servlet</CODE>, we <EM>enable</EM> the default servlet in our <CODE>@Configuration</CODE>
    class.
    The default servlet is unique to each web container, and not specified by any standard.
    Spring MVC can be made to depend on this functionality, if it's available, if you <EM>enable</EM> it.
    It supports a wide range of deployment targets, though - so chances are it will work for you if you're
    running this application in Tomcat, Jetty, JBoss, and GlassFish, Google App Engine, Resin, WebLogic or WebSphere.
    Here's our revised configuration class, this time enabling the <EM>default</EM> Servlet. </P>

<div class="git-gist" gist="5060799"> defaultServlet.enable()</div>
<P> Once we have the <EM>default</EM> servlet in place, we can put it to work, letting it render a few resources we
    don't want to write handlers for ourselves. This will automatically employ the <EM>default</EM> servlet to render
    all requests to <code>/web/*</code> and render the appropriate resource in the <CODE>/web/</CODE> directory in the
    web application. </P>


<Div class="git-gist" gist="5060815"> addResourceHandlers()...</Div>

<h3> View Controllers </h3>

<!-- now we need to introduce how to handle view controllers. but the things is, theyve not yet seen the full controllerl ifecycle. so perhaps i can introduce that above? -->
<P> Some pages in an application are read-only - they don't require any functionality or processing logic. It would seem
    silly to implement a controller and a request handler just to render a view. Spring MVC can handle this eventuality
    easily: simply declare <EM>view controllers</EM> in the configuration class by overriding the <CODE>addViewControllers</CODE>
    method, like this: </P>

<div class="git-gist" gist="5067566"> addViewControllers()</div>
<P> Here, we use the <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.config.annotation.ViewControllerRegistry</CODE>
    to map URLs to view names. For example, <CODE>/</CODE> gets mapped to <CODE>/signin</CODE>, so that the first page
    anyone sees is the signin form. We also map other URLs (like <CODE>/crm/signin.html</CODE>) to appropriate views -
    in this case, <CODE>signin</CODE>. </P>

<P> While we're taking care of these sorts of things, let's configure an error handling page. If a component in our web
    application throws an exception, Spring MVC can redirect to an error page and optionally return an error code for
    us. For now, we'll install a catch-all error page view by overriding the
    <CODE>configureHandlerExceptionResolvers</code> method. Here, we've specified that the view named <CODE>oops</CODE>
    (which we defined above as a <EM>view controller</EM>) is to be rendered whenever there's an error, and a <span
            class="wikipedia">HTTP_404</span> code is to be returned. </P>

<div class="git-gist" gist="5067711"> configureHandlerExceptionResolvers</div>


<h3> Where do I Put Common Logic Across All Requests? </h3>

<P> There is some data that is reprinted as part of the Apache Tiles template on every page - data like the sign-in
    <CODE>user</CODE>s ID and username. This is information we could derive from the <CODE>user</CODE> itself. Instead
    of making a mess of the session simply to dereference values, and instead of long expressions in our templates,
    we'll simply recreate the values in a common place that gets executed across <EM>all</EM> requests to the
    application. Let's take advantage of Spring MVC's powerful <EM> <A
            href="http://static.springsource.org/spring-framework/docs/current/spring-framework-reference/htmlsingle/#mvc-config-interceptors">
        interceptor</a></EM> support. The values we want, specifically, are the user's <CODE>userId</CODE>, and <CODE>username</CODE>.
    These values can be made available inside the interceptor, and then dereferenced from our controllers and templates.
    That way, when we later change the way we lookup the current, authenticated user, the templates will need not change
    accordingly. We simply change our <code class="class-reference" module="spring-webmvc">org.springframework.web.context.request.WebRequestInterceptor</code>
    implementation and the values will update accordingly. </p>

<P> The <CODE>WebRequestInterceptor</CODE> SPI lets you act on all requests, before a request has been handled by a
    Spring MVC controller (<CODE>preHandle(WebRequest req)</code>), after a request has been handled by a Spring MVC
    controller (but before the <EM>view</EM> has been rendered; (<CODE>postHandle(WebRequest req, ModelMap model)</code>)),
    and after Spring MVC has finished processing the request entirely (<CODE>afterCompletion(WebRequest request,
        Exception ex)</code>). Our code simply inspects the current HTTP session (if it's available) and extracts
    information about the authenticated user and puts that information in the request attributes where it's available
    from inside of the view. </P>

<div class="git-code" extension="java" q="tut_web" module="web">
    org.springsource.examples.spring31.web.interceptors.CrmHttpServletRequestEnrichingInterceptor
</div>
<P> We need only override one more method in the <CODE class="class-reference" module="web" q="tut_web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</CODE>,
    <CODE>addInterceptors</CODE>, to register our custom interceptor, like this: </P>

<Div class="git-gist" gist="5087185"> addInterceptors()</Div>


<h3> Internationalization </h3>

<P>
    We don't live in monolingual world, and web applications can't afford to ignore the languages their users speak.
    Spring MVC can
    detect the <em>locale</em> from each users HTTP requests. This can be used to give our application an idea
    about what language the user is expecting language strings to be rendered in.
    Spring MVC can look up message strings in <EM>resource bundles</EM>.
    The JDK supports <CODE class="class-reference" module="java">java.util.ResourceBundle</CODE>s, which
    map a given key and language combination to a string in a specific language and localized to a specific region.

</p>

<div style="margin-bottom: 10px" class="diagram">
    <table>
        <thead>
        <TR>
            <th> Language</th>
            <th> Language Code</th>
            <th> Country Code</th>
            <Th> Example Resource Bundle File Name</Th>
        </TR>
        </thead>

        <TR>
            <td>English</td>
            <td>en</td>
            <td>(none)</td>
            <TD><CODE>messages_en.properties</CODE></TD>
        </TR>
        <TR>
            <td>French</td>
            <td>fr</td>
            <td>(none)</td>
            <TD><CODE>messages_fr.properties</CODE></TD>
        </TR>
        <TR>
            <td>German</td>
            <td><CODE>de</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_de.properties</CODE></TD>
        </TR>
        <TR>
            <td>Italian</td>
            <td><CODE>it</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_it.properties</CODE></TD>
        </TR>
        <TR>
            <td>Japanese</td>
            <td><CODE>ja</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_ja.properties</CODE></TD>
        </TR>

        <TR>
            <td>Chinese</td>
            <td><CODE>zh</CODE></td>
            <td>(none)</td>
            <TD><CODE>messages_zh.properties</CODE></TD>
        </TR>
        <TR>
            <td>Chinese Spoken in China</td>
            <td><CODE>zh</CODE></td>
            <td><Code>CN</Code></td>
            <TD><CODE>messages_zh_CN.properties</CODE></TD>
        </TR>
        <TR>
            <td>Chinese Spoken in Taiwan</td>
            <td><COde>zh</COde></td>
            <td><CODE>TW</CODE></td>
            <TD><CODE>messages_zh_TW.properties</CODE></TD>
        </TR>
        <TR>
            <td>French Spoken in France</td>
            <td><code>fr</code></td>
            <td><CoDE>FR</CoDE></td>
            <TD><CODE>messages_fr_FR.properties</CODE></TD>
        </TR>

    </TABLE>
    <span class="caption">  Some common country code and language code designations and an example properties file name for that language and/or country. </span>
</div>

<P>

    Resource bundles contain locale-specific objects. When your program needs a locale-specific resource, a
    <CODE>String</CODE> for example, your program can load it from the resource bundle
    that is appropriate for the current user's locale. In this way, you can write program code that is largely
    independent of the user's locale.

    We register an instance of <CODE class="class-reference" module="spring-webmvc">org.springframework.web.servlet.i18n.SessionLocaleResolver</CODE>
    to detect the current users <CODE>Locale</CODE> and store it for reference in the session. The <CODE>Locale</CODE>
    stored in the HTTP session can be
    overriden with a request parameter. We enable this by installing one more <EM>interceptor</EM>, an instance of the
    <CODE class="class-reference" module="spring-webmvc">
        org.springframework.web.servlet.i18n.LocaleChangeInterceptor </CODE>.

    Finally, we register an instance of <CODE class="class-reference" module="spring-webmvc">org.springframework.context.support.ResourceBundleMessageSource</CODE>
    which looks at resource bundles for translation keys having a <code>basename</code>. We've specified the <CODE>basename</CODE>
    <code>messages</code>.
    Thus, if a user's <CODE>Locale</CODE> indicates that the user speaks the German language (de) in Switzerland (CH),
    Spring MVC will attempt to load <CODE>messages_de_CH.properties</CODE>, before then trying the more generic <CODE>messages_de.properties</CODE>
    for all German-language speaking countries.
    If that doesn't work, it'll fall back to the resource bundle for the specified <Em>default</Em> <CODE>Locale</CODE>.

    We'll look at how this internationalization support can be used in our application later when we introduce form
    validation and demonstrate how to create templates with internationalized strings.

</P>

<!-- todo i18n && MessageSource should be covered more in the first -core Spring - tutorial -->

<P class="todo">For more on Spring's <code module="spring-webmvc" q="tut_web" class="class-reference">org.springframework.context.MessageSource</code>,
    please see the first tutorial on core Spring.
</P>

<div class="git-gist" gist="5115482"></div>

<H3>Final Configuration</H3>

<P> Our application can now serve complex pages using Apache Tiles, JSP, and we can easily stream resources like
    JavaScript and CSS files. We've setup Spring MVC and now we can move on to the final leg of this tour through basic
    Spring MVC. </P>

<div module="web" q="tut_web" extension="java" class="git-code">
    org.springsource.examples.spring31.web.config.WebMvcConfiguration
</div>

<h2>Building A Simple Sign In Page with a Form </h2>

<P> Let's build our first view, supporting basic login, which requires form processing. The implementation logic for
    this login page is in <span module="web" q="tut_web" class="class-reference">org.springsource.examples.spring31.web.ViewController</span>.
</p>

<div module="web" q="tut_web" extension="java" class="git-code">org.springsource.examples.spring31.web.ViewController
</div>
<P> The obvious things: this is a Spring MVC controller, that handles both HTTP <CODE>POST</CODE> and <CODE>GET</CODE>
    requests to the same URL, <CODE>/crm/signin.html</CODE>. Since all handlers in the class are for a common URL, we've
    mapped the URL in one place, at the class, in a <span class="class-reference" module="spring-webmvc">org.springframework.web.bind.annotation.RequestMapping</span>.
    There are some values that are shared in multiple places, so those values are stored as <CODE>public static final
        String</CODE> values in the class. </P>

<p> We have two use cases. How will people arrive at this form? They'll visit the URL <CODE>/crm/signup.html</CODE> in
    their browser. That requires handling an HTTP <CODE>GET</CODE> call. The request handler doesn't do anything, it
    simply renders the view provided. </p>

<div class="git-gist" gist="5114686"></div>
<P> Then, once the users have landed, they'll input values into the form (data that we will want to work with in terms
    of a <code>SignInAttempt</code> object) and then submit, or <CODE>POST</CODE> the data to the URL <CODE>/crm/signup.html</CODE>.
    That requires handling an HTTP <CODE>POST</CODE> call that contains form data that needs to be validated. </p>

<div class="git-gist" gist="5114830"></div>
<P> The values will come from the client in the request as the request parameters <code>username</code> and <CODE>password</CODE>.
    As written, the request handler declares three parameters of type <CODE class="class-reference" module="web"
                                                                            q="tut_web">org.springsource.examples.spring31.web.SignInAttempt</CODE>,
    <code class="class-reference" module="spring-webmvc">org.springframework.validation.BindingResult</code>, and <code
            class="class-reference" module="spring-webmvc">org.springframework.ui.Model</code> respectively. The first
    argument - of type <span class="class-reference" module="web" q="tut_web"> org.springsource.examples.spring31.web.SignInAttempt</span>
    - is annotated with two annotations: <CODE class="class-reference" q="spring-webmvc" module="spring-webmvc">org.springframework.web.bind.annotation.ModelAttribute</CODE>
    and <CODE module="servlets" class="class-reference" q="spring-webmvc">javax.validation.Valid</CODE>. Let's look
    first at the <span class="class-reference" module="web" q="tut_web"> org.springsource.examples.spring31.web.SignInAttempt</span>.
</p>

<DIV class="git-code" extension="java" module="web" q="tut_web">org.springsource.examples.spring31.web.SignInAttempt
</DIV>
<P><CODE class="class-reference" q="spring-webmvc" module="spring-webmvc">org.springframework.web.bind.annotation.ModelAttribute</CODE>
    tells Spring MVC that the request handler is expecting an object of the type annotated. By default, Spring MVC will
    attempt to instantiate an instance of the class using a <EM>default</EM> constructor. It will use JavaBean
    conventions and set properties on the object based on request parameters. Thus: the <CODE>SignInAttempt</CODE>
    object will be created, and its <CODE>username</CODE> field will be set from the HTTP request attribute <CODE>username</CODE>,
    and its <Code>password</Code> field will be set from the HTTP request attribute <CODE>password</CODE>. </P>

<P> If you want to synthesize the model object yourself - perhaps because you want to call a different constructor or
    build the object based on more than just request parameters - you can annotate a factory method with <CODE
            class="class-reference" q="spring-webmvc" module="spring-webmvc">org.springframework.web.bind.annotation.ModelAttribute</CODE>.
    This factory method can access anything from the request it wants. We could declare our own
    <CODE>@ModelAttribute</CODE> factory method in the controller to construct the <span class="class-reference"
                                                                                         module="web" q="tut_web"> org.springsource.examples.spring31.web.SignInAttempt</span>.
    <CODE>@ModelAttribute</CODE> factory methods can declare all the same arguments as request handlers. Here's a <code>@ModelAttribute</code>
    factory method that uses a non-default constructor. </P>

<DIV class="git-gist" gist="5114560">@ModelAttribute public SignInAttempt signInAttempt</DIV>
<P><CODE>@Valid</CODE> is a <em>Java Validation API</Em> (<A href="http://jcp.org/en/jsr/detail?id=303">JSR 303</A>)
    annotation that signals that the bean it annotates has <EM>constraint</EM> annotations declared on its fields. These
    <EM>constraints</EM> are declarative. The class is a regular Java Object that declares two String fields, named the
    same as the request parameters: <CODE>username</CODE> and <CODE>passsword</CODE>. It has a default constructor, and
    the fields have accessor (<code>get*</code>) and mutator methods (<code>set*</code>). It also declares validation
    constraints through annotations on each field. For example, the <COde>username</COde> field is required to have a
    valid, non-empty email string: </P>

<DIV class="git-gist" gist="5114717"> @Email private String email ;</DIV>
<P> Spring MVC will make any errors available for us in our second argument, an instance of <CODE
        class="class-reference" q="tut_web" module="spring-webmvc">org.springframework.validation.BindingResult</CODE>.
    In the code for the request handler, we use the <CODE>BindingResult</CODE> to check for errors and short circuit an
    attempt to login and - if we proceed with the login but encounter an error - to register new errors. We use the
    <CODE>reject</CODE> method to signal that the attempt to login failed to return a valid reference. We give the
    method a <EM>message code</EM> (<code>login.invalid</code>) and a default error message to be rendered if the
    message code doesn't exist yet (this is useful for debugging purposes). We'll look more at message codes in the next
    section. </P>

<p>Finally, we declare an argument of type <CODE>Model</CODE>, which is basically a glorified hash map that stores
    values in the various web server memory storage caches: the current HTTP request context, the HTTP session context,
    etc. By default values are stored and endure as long as the request they're created for. Because we want the model
    object for the <CODE>user</CODE> to live for as long as the current user is signed in, we use the <CODE>@SessionAttributes(ViewController.USER_OBJECT_KEY) </CODE>
    at the class level to signify that the <code>user</code> model attribute should be stored in the HTTP session.
    Values in the <CODE>Model</CODE> object are also available for reference during the render. We use this object to
    store the authenticated user into the model attribute <code>user</code>. </p>

<P> If there are any errors, the method returns the String <CODE>"signin"</CODE> to signal that <CODE>signin</CODE> view
    should be re-rendered to present the user with feedback about the errors. If there are no errors, the method returns
    the String <CODE>"redirect:/crm/profile.html"</CODE>, which Spring MVC will handle by sending a redirect (a separate
    <CODE>HTTP GET</CODE> call) to the user's <code>profile</code> page. </P>

<h3> Internationalization with Spring MVC </h3>

<p> In the previous section, we used the <code>reject</code> method on the <CODE>BindingResult</CODE> argument to
    register an error, passing in a <EM>message code</EM> that corresponds to a message in the resource bundle we setup
    earlier in our configuration class. As explained earlier, Spring MVC will look up the message key based on the
    current HTTP session's <CODE class="class-reference" module="java">java.util.Locale</CODE>. Let's look at the page
    markup for the sign in form: </P>

<div module="web" q="tut_web" class="git-code" extension="jsp"> src/main/webapp/WEB-INF/views/signin/signin.jsp</div>
<P> The page is a standard <CODE>.jsp</CODE> page that relies on the Apache Tiles tags (defined by the tag namespace
    <CODE>http://tiles.apache.org/tags-tiles</CODE>) to enclose a region of markup and set it as the value to be
    rendered in the <CODE>content</CODE> tile in the Tiles layout.
</p>

<P>
    The page also relies on the Spring tags, defined by
    the tag namespace <CODE>http://www.springframework.org/tags</CODE> to setup the form, and to handle dealing with
    presenting internationalized errors and text labels to the user.
    The declaration <CODE> &lt;form:errors element="li" path="*"/&gt;</CODE> tells Spring MVC to
    render the errors currently stored in the <CODe>BindingResult</CODe> inside of <CODE>&lt;li&gt;</CODE> elements. We
    use the <CODE>path</CODE> attribute to tell Spring MVC that it should render <EM>all</EM> errors. In the template
    itself - and throughout the site - wherever user prompts are expected, we use the <CODE>&lt;spring:message code
    =".." &gt;</CODE> element to import text resources from the resource bundle based on a key. Both the label
    handling and the error handling rely on Spring's internationalization support. </P>

<P> The <CODE>&lt;spring:form&gt;</code> tag establishes that we expect the fields in this form (one for
    <CODE>username</CODE> and one for <CODE>password</CODE>)
    to be mapped to a <EM>command object</EM> - which refers to the same object as the <CODE>@ModelAttribute</CODE>-annotated
    argument to the HTTP <CODE>POST</CODE> request handler.

</P>

<P> The rest of the page is standard HTML markup to render an HTML form complete with interactive JavaScript feedback
    and styling.
    We now have a working sign in form!
</P>

<h1> The Changing Face of the Web: Working with Business State using REST </h1>

<h2> The Smarter Client </h2>

<P>

<div style="float:left;margin-right:10px; width: 520px;">
    <div style="margin-bottom: 10px" class="diagram"><img src="images/green-screen-dinosaur.jpg"/> <span
            class="caption"> Computer monitors used to come in three colors: green, white, and amber, always on a black background. </span>
    </div>
    <div style="margin-bottom: 10px" class="diagram"><img src="images/tim-berners-lee-NextCube.jpg"/> <span
            class="caption"> Tim Berners-Lee's NextStep Cube. I love the warning on the machine - "This machine is a server. DO NOT POWER DOWN!!" Imagine the implications! Imagine <EM>powering
        down</EM> <B>the web</B>! Eeery. </span></div>
</div>
Before the 'web, we had mainframes and thin clients. These clients were remarkably stupid. No client side state at all.
The server would send down the updates to the clients and the clients would render them. Every time. <a
        href="http://www.w3.org/People/Berners-Lee/">Tim Berners-Lee</a> invented the World Wide Web while at CERN, the
European Particle Physics Laboratory, in 1989. He wrote the first web client and server in 1990. His specifications of
URIs, HTTP and HTML were refined as Web technology spread. The initial makeup of the web was fairly underwhelming. The
first several years were uneventful because the clients - HTTP browsers - were no more impressive than the green-screen
clients they replaced. They were dumb. <EM>Very</EM> dumb. Slowly, functionality was added to make the browsers smarter.
As time progressed, the community devised of stopgap solutions to make the web a nicer place to build web applications.
These were, on the whole, hacks. As time progressed, these hacks were baked into the browsers and into the standards
driving HTTP, HTML and the web in general. </P><P> To keep pace, the client-side browsers have taken a quantum leap in
    the last decade! Now, we have <EM>really</EM> smart clients. JavaScript, the language that runs within the browsers,
    has grown by leaps and bounds and can do <EM>almost </EM> anything. Witness, for example, <a
            href="http://bellard.org/jslinux/">this JavaScript PC emulator by Fabrice Bellard </a>. It boots Linux.
    Seriously. When you run it, it dumps you into a shell where you can use <code>vi</code> to edit the file <CODE>hello.c</CODE>.
    Then, you can recompile it and run it. All within Linux. Inside of a browser. Using an emulator written in
    JavaScript. </P> <!-- todo link to our tutorial on cujos--> <P> What role does the server play here? While
    individual resources, such as CSS and images and JavaScript, are served up by the web server, and while initial HTML
    pages are sent down from the server, much of the interaction that happens between the user and the user interface
    happens these days entirely on the client. The server doesn't really need to get involved too much in rendering
    HTML, besides serving the initial page load and the resources to support it. Nowadays, the client can do a
    <EM>lot</EM> of interesting things, and doesn't need to rely on the server to keep user-interface state. Indeed all
    the server has to do is keep <EM>business</EM> state, and make that available to the client. </p>

<P> Today, <span class="wikipedia"> REST </span> (or <EM>representational state transfer</EM>) is the most common way to
    expose server side business state to clients. REST builds upon the principles of HTTP, so doesn't require any new
    infrastructure or any specialized types of middleware. There are some fundamental principles behind REST. </p>

<H2> Designing RESTful Resources with Spring </H2>

<!-- todo interleave the relevant Spring MVC handler method syntax as u introduce concepts for REST-->

<P>
    Spring's support for REST builds upon the basic Spring MVC component model.
    You've already been introduced to Spring MVC controllers, and so are more than halfway there. Our application deals
    with two different types of data, or entities: <CODE class="class-reference" q="tut_rest" module="services">
    org.springsource.examples.spring31.services.User </CODE> and
    <CODE class="class-reference" q="tut_rest" module="services">
        org.springsource.examples.spring31.services.Customer</CODE>.


    We'll build RESTful web services to support manipulating these entities.

    Let's add a controller -
    <CODE class="class-reference" q="tut_rest"
          module="web">org.springsource.examples.spring31.web.UserApiController</CODE> - which will manage the <COde>User</COde>
    information. The controller will expose endpoints to handle common operations for a <CODE>User</CODE>. A
    <CODE>User</CODE> will login, manage her profile, and manage <CODE>Customer</CODE> records.
    First, let's look at the code, then we'll dissect the novel parts.

</P>


<div module="web" q="tut_rest" extension="java" class="git-code">
    org.springsource.examples.spring31.web.UserApiController
</div>
<P> This code should look fairly familiar. It's a set of Spring MVC controllers that deal with requests to various URIs.
    There are a couple of novel things in this code, however.

</P>


<h3> URI Structures </h3>
<p>



    HTTP resources
    (URIs) map to data hierarchies, like directory structures, in an easily understood way. Suppose, for example,
    that you want to map customer data from a CRM-style application (like ours!) to HTTP URIs.
    You might use <code>http://localhost:8080/crm/customers</code> to expose <EM>all</EM> the customers.
    You might use <CODE>http://localhost:8080/crm/customers/42</CODE> to expose information specifically about a
    customer whose ID is <CODE>42</CODE>.
    You might use <CODE>http://localhost:8080/crm/customers/42/orders</CODE> to expose information about the <CODE>orders</CODE>
    of that same <CODE>customer</CODE>.

    Here's the request handler to retrieve <CODE>User</CODE> data by ID.
</p>

<DIV class="git-gist" gist="5129983">
    @RequestMapping @ResponseBody public void userById( @PathVariable ...)
</DIV>
<P>
    This method is very similar to the request handlers we've seen thus far! It has a <CODE class="class-reference"
                                                                                            module="spring-web">org.springframework.web.bind.annotation.RequestMapping</CODE>
    annotation
    establishing the method as a handler. It specifies a URL and an HTTP method (<CODE>GET</CODE>) that it can respond
    to.
</P>

<P> The <CODE>public static final</CODE> field, <CODE>USER_COLLECTION_ENTRY_URL</CODE>,
    is a <CODE>String</CODE> that we've defined once and built upon to ensure consistent URIs. The final URL is <CODE>/api/users/{userId}</CODE>.


</P>

<CODE class="git-gist" gist="5130002">
    static public final String USER_COLLECTION_URL = "/api/users";
    static public final String USER_COLLECTION_ENTRY_URL = USER_COLLECTION_URL + "/{userId}";
</CODE>

<P>
    Any token contained in braces (like: <CODE>{userId}</CODE>) is a <EM>path variable</EM>. Spring MVC will treat that
    as a wild card, extract the value out from each request and
    inject the value into any request handler method argument annotated with <CODE class="class-reference"
                                                                                   module="spring-web">org.springframework.web.bind.annotation.PathVariable</CODE>,
    like this:
    <CODE>@PathVariable("userId") Long userId</CODE>. If, for example, someone opened the URL <CODE>/api/users/24</CODE>
    in a browser, the request handler method (<CODE>getUserById</CODE>) would be invoked
    and the value <CODE>24</CODE> would be converted to a type of <CODE class="class-reference" module="java">java.lang.Long</CODE>
    and passed as an argument to our controller method. Of course, path variables are just as naturally used with
    regular Spring MVC and <EM>classic</EM> web applications.
</P>
<h3>Content Negotiation</h3>

<P>
    The return value is annotated with the <CODE class="class-reference" module="spring-webmvc">org.springframework.web.bind.annotation.ResponseBody</CODE>
    annotation.
    When Spring MVC sees this annotation, it short circuits the view resolution process that's normally at play, and
    attempts to convert the returned value into a representation that the HTTP client can work with.
    The client signals which representation formats it's prepared to accept through a process called <EM>content negotiation</EM>, a
     fundamental feature of HTTP.   Usually, the client sends a <CODE>Accept</CODE> header that specifies which representation formats it's prepared to read.
</p>

<P>
     On the server side, Spring MVC uses the <EM>strategy pattern</EM> to delegate the conversion to a configured
    <CODE class="class-reference" module="spring-webmvc">org.springframework.http.converter.HttpMessageConverter</CODE> instance.

    We could easily add our own custom <CODE>HttpMessageConverter</CODE> types in our configuration class by overriding the <code>configureMessageConverters</code> method, but there is rarely any need to.
    Depending on what is available on your CLASSPATH, Spring MVC will automatically support marshalling
    XML with a JAXB implementation and JAXB-annotated POJOs, JSON through the Jackson JSON library, multipart file data
    through the <A href="http://commons.apache.org/proper/commons-fileupload/">Apache Commons FileUpload </A> library or
    the Servlet 3 Part API,
    RSS and ATOM feeds with the ROME library, and images using the <code>java.awt.image.BufferedImage</code> API and
    more.

    Thus, if a client requests the data in one of these URLs and species that it will only <CODE>Accept</CODE> data of
    the type <CODE>application/json</CODE>,
    then the client will attempt to convert the results into JSON and send it in the response body.
</p>

<h3>HTTP Verbs</h3>
<p>
     HTTP methods should be used explicitly.
    HTTP methods (<CODE>POST</CODE> , <CODE>DELETE</CODE>, <CODE>PUT</CODE>,
    <CODE>GET</CODE> map nicely to the state transitions (creation, deleting, updating, reading and querying,
    respectively) our enterprise data typically goes through. </p>
<ul>
    <LI><CODE>GET</CODE>, for example, can be used to retrieve information. It must be safe, and idempotent. It can have
        side effects, but since the user doesn't expect them, they shouldn't be critical to the operation of the system.
        GET can be conditional or partial based on the presence of the HTTP headers <CODE>If-Modified-Since</CODE> or
        <COde>Range</COde>. A HTTP <CODE>GET</CODE> request looks like this: <CODE>GET /api/crm/42/customers/242</CODE>.
        This would be expected the entity identified by <CODE>242</CODE> holding customer data.
    </LI>
    <LI><CODE>DELETE</CODE>s can be used to delete information identified by a URL. A <CODE>DELETE</CODE> request looks
        like this: <CODE>DELETE /api/crm/42/customers/242</CODE>. A <CODE>DELETE</CODE> request can
    </LI>
    <LI>
        Usually, a <CODE>PUT</CODE> requests that the payload of the request be used to update or create a resource on
        the server
        with a specific ID. Thus, <CODE>PUT /api/crm/42/customers/243</CODE> might create a new customer record
        identified by the
        number <CODE>242</CODE>, and can return a response. Such a response might be <CODE>{ "name" : "Mark", "id" :
        "242" }</CODE>.
    </LI>
    <LI>
        Usually, a <CODE>POST</CODE> requests that the payload of the request be used to update or create a resource on
        the server with
        <EM>no</EM> specific ID. Thus, <CODE>POST /api/crm/42/customers</CODE> might create a customer record and then
        return that as the response,
        just as with <CODE>PUT</CODE>: <CODE>{ "name" : "Mark", "id" : "242" }</CODE>.
        You might respond with an HTTP status code. For example, you could return an <CODE>HTTP 201 Created</code> code
        and a <CODE>Location</CODE> header with the URI that points to the newly created resource.
    </LI>

</ul>

<h3>HTTP Status Codes
</h3>

<P> HTTP supports status codes to convey system state to clients in a consistent way. These take the place of things
    like exceptions in programming languages. Status codes are an indicator the result of the server's attempt to
    satisfy the request. These status codes are returned in the response from the server. Status codes are broadly
    divided in categories: </P>
<ul>
    <LI><b>1XX</b>: Informational</LI>
    <LI><b>2XX</b>: Success</LI>
    <LI><b>3XX</b>: Redirection</LI>
    <LI><b>4XX</b>: Client Error</LI>
    <LI><b> 5XX</b>: Server Error</LI>
</ul>
<P>
    By default Spring returns HTTP 200 on successful requests.
    HTTP 200 means "everything worked."
    You don't need to indicate this status code if everything succeeds.
    You can, in specific cases, provide a different status code using the <CODE module="spring-webmvc"
                                                                                class="class-reference">org.springframework.web.bind.annotation.ResponseStatus</CODE>
    annotation
    on the Spring MVC request handler.
</P>

<h3> Our RESTful Controller </h3>

<P>
    Let's look at a Spring MVC controller for working with <CODE class="class-reference" module="services">org.springsource.examples.spring31.services.User</CODE>s.

</P>


<!--


<p> Data coming from these resources should be represented in an easily understood way. For example as XML document, or
    as a JSON object, or both, depending on the capabilities supported by the resource and the requirements of the
    client. This is a fundamental tenant of the web, called <EM>content negotiation</EM>. Content negotiation is most
    commonly done using the <CODE>Accept</CODE> header on requests. If a client sends a request with <CODE>Accept=application/json</CODE>
    then the client is expecting a response in the mime type <CODE>application/json</CODE>. If the server resource can
    encode data this way then it should. </p>

<P> Services are stateless. Because HTTP is stateless, you should design your services themselves to be as stateless as
    possible. Of course there's business state, but you shouldn't attempt to keep things in some sort of session. There
    are some, useful, exceptions such as when we introduce OAuth sessions which require minimal state and can't be
    arbitrarily bound to. There are a lot of benefits to this, though. For example, if you want to scale your
    application you can simply add more HTTP servers are requests can be routed across them randomly with no loss of
    context. </P>


<P> There are two aspects to Spring's support story for REST, the client side perspective and the server side
    perspective. </P>

<P>

    From the client side, to support connecting to RESTful web services, Spring features the <code class="class-reference" module="spring-webmvc">org.springframework.web.client.RestTemplate</code>.
    <code>RestTemplate</code> reduces common HTTP access operations to one-liners.  The <CODE>RestTemplate</CODE> is very configurable.
    The <CODE>RestTemplate</CODE>
    can handle mapping results from requests to more useful types (through the <CODE class="class-reference"
                                                                                     module="spring-webmvc">
        org.springframework.http.converter.HttpMessageConverter </CODE> SPI) and aspect-like concerns like security
    authorization transmission (through the <CODE class="class-reference" module="spring-webmvc">
        org.springframework.http.client.ClientHttpRequestInterceptor </CODE> SPI). We'll cover the
    <CODE>RestTemplate</CODE> a bit more when we look at <A href="http://www.springsource.org/spring-social">Spring
        Social</a>, but for a really detailed look at this class, and the peer class provided as part of the <A
            href="http://www.springsource.org/spring-android">Spring Android</a> project to enable secure RESTful access
    from Android, check out our tutorial <span class="todo">on client-side application development with Spring</span> .
</P>

<P> What concerns us in this tutorial is how to design and standup RESTful webservices. We've already been introduced to
    Spring MVC's component model and the API it uses to standup HTTP endpoits. We'll look more closely in this section
    at handling different kinds of requests and we'll see how the handling of one type of request for an HTML resource
    is really not very different than the handling of a request for a RESTful resource. </P>
-->
<P> We'll need to retrieve user details by criteria. Different kinds of criteria, but we can imagine wanting to retrieve
    their information by IDS, at least. </p>

<P> You'll want to be able to create new users. </P>

<P> You'll need to be able to update a users details. </P>

<p> You'll need an endpoint to handle file uploads for the profile's photo image </p>

<p> You'll need an endpoint to render the files uploaded for the profile's photo image </p>
<!-- todo when we introduce the REST endpoitns be sure to introduce Spring Rest Shell -->
<!--<h3> Use Cases for Our RESTful Services </h3> <P> Let's revisit our existing application and the screens involved. What what data do we need access to? </P>-->
<script type="text/javascript" language="JavaScript"> $(function () {
    setTimeout(function () {
        window.scrollTo(0, document.body.scrollHeight);
    }, 1000);
}) </script>
<A name="eof"/></body>
</html>