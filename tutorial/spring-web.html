<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head><title>The Spring Tutorial: Web </title>
    <!-- todo jquery logic to make all class-reference spans links to the javadocs for the code todo jquery logic to make all wikipedia spans links to the wikipedia entry for the text therein. -->
    <style type="text/css"> .wikipedia {
    }

    .diagram {
        width: 500px;
    }

    table, th, td, th {
        vertical-align: top;
    }

    .diagram img {
        width: 500px;
    }

    .caption {
        font-style: italic;
        font-size: smaller;
        display: block;
    }

    code, .git-code, .class-reference {
        font-family: courier, monospace;
        /* background-color: #dcdcdc;*/
    } </style>
    <script src="js/jquery-1.8.3.min.js"></script>
    <script type="text/javascript">
        /* we need to support several types of handlers */

        $(function () {


            //// global functions

            //
            // module supporting resolution of SpringSource JavaDoc URLs

            var StringUtils = {
                encodeFullyQualifiedPath: function (ref) {
                    var url = ref;//
                    while (url.indexOf('.') != -1) {
                        url = url.replace('.', '/');
                    }
                    return    url + '.html'
                },
                classForFullyQualifiedClass: function (ref) {
                    var lastPeriod = ref.lastIndexOf('.');
                    if (lastPeriod == -1)
                        return ref;
                    return  ref.substring(lastPeriod + 1);
                }
            };

            function GenericModule(self, bu) {
                self.baseUrl = bu;
                self.urlForCodeReference = function (ref) {
                    return self.baseUrl + StringUtils.encodeFullyQualifiedPath(ref);
                };
                self.labelForCodeReference = function (ref) {
                    return StringUtils.classForFullyQualifiedClass(ref);
                };
            }

            function ServletsModule(baseUrl) {
                GenericModule(this, 'http://docs.oracle.com/javaee/6/api/');
            }

            function SpringModule(baseUrl) {
                GenericModule(this, 'http://static.springsource.org/spring/docs/current/javadoc-api/');
            }


            //
            // generic visitor function that can be used to cherry pick DOM elements and
            // return the correct implementations of the DOM element sbased on CSS selectors
            function visitElements(css, attrs, callback) {
                $(css).each(function (indx) {
                    var node = $(this);
                    var classRefValue = node.html().trim();
                    var collectedAttributes = {};
                    for (var i = 0; i < attrs.length; i++)
                        collectedAttributes[ attrs[i]] = node.attr(attrs[i]);
                    callback(node, classRefValue, collectedAttributes);
                });

            }

            // todo class-reference && module
            var mapOfModulesToLinks = {};

            // first lets bootstrap
            visitElements('.class-reference', ['module'], function (node, val, attrs) {
                mapOfModulesToLinks [attrs['module']] = {};
            });

            // then we register module handlers for the 'spring-*' modules
            for (var x in mapOfModulesToLinks) {
                if (x.indexOf('spring-') != -1)
                    mapOfModulesToLinks[x] = new SpringModule();
            }
            mapOfModulesToLinks ['servlets'] = new ServletsModule();

            // then we handle .class-reference elements
            visitElements('.class-reference', ['module'], function (node, val, attrs) {
                try {
                    val = val + '';
                    var processor = mapOfModulesToLinks[attrs['module']];
                    var url = processor.urlForCodeReference(val),
                            label = processor.labelForCodeReference(val);
                    console.log('the url is ' + url)
                    node.html('<A href="' + url + '">' + label + '</A>');
                } catch (e) {
                    console.log('ERROR! ' + e)  //  console.log('hit an error ' + e)
                }
            });

        });

    </script>
</head>
<body>

<h1> Building Web Applications with Spring MVC </h1>

<h2>Welcome</h2>

<P>

    Let's build a simple web application to see how the moving parts fit together. Our application will be a simple
    Customer Relationship manager (CRM) of sorts. Users can create an account, login and then manage simple customer
    records. We already have Hibernate-based backend services that manage user (<span module="services"
                                                                                      class="class-reference">org.springsource.examples.spring31.services.UserService</span>)
    and customer (<span module="services" class="class-reference">org.springsource.examples.spring31.services.CustomerService</span>)
    data for us. We're using <A href="http://maven.apache.org">the Apache Maven</A> build tool to include those classes
    in our web application. <SPAN class="todo">To learn more about how to assemble basic service objects with the Spring framework, or how to use Apache Maven, please see our introduction tutorial.</SPAN>
</p>

<P> TODO we need to show them how to setup the database and the sample application
    Check out the data tutorial for details on data access with SPring. For a complete step by step introduction
    opn how to setup the sample application please refer to the <CODE>README</CODE>.
</P>

<P> In this tutorial we will show you how to do these things with Spring MVC: </p>
<uL>
    <LI> Create a working web application</LI>
    <LI> Handle form submissions</LI>
    <LI> Build a screen to handle data</LI>
    <LI> Learn how to expose your data as RESTful webservices</LI>
    <LI> Learn how to work with Spring Security for login and logout support</LI>
    <LI> Learn how to work with OAuth and Spring Security OAuth</LI>
</uL>

<h3> Setting Up the Tool Chain </h3>

<P>
    TODO show how to import the code and where to get it and how to use STS File &gt; Import and how Maven helps us.

    Our tutorial is tool agnostic, but we recommend the free STS edition which comes wiht all sorts
</P>


<h2> Building Web Applications with MVC</h2>

<p> The original code in Spring was written to support the web. Indeed, the earliest classes (like, <span
        module="spring-web" class="class-reference">org.springframework.web.context.WebApplicationContext</span>) that
    Spring founder Rod Johnson wrote in his study in England in 2001 were to support Java-based web applications
    environments. Spring's always had a great support for the web. From the beginning, Spring has featured an MVC
    framework, called Spring MVC. Spring MVC at the time looked conceptually very similar to the then entrenched Struts
    framework. While Spring MVC evolved on its own merits, Spring did everything possible to ease the lives of
    developers using other web frameworks, like Struts. The Spring-Struts integration support in the core Spring web
    modules made Struts a much nicer proposition for developers who were stuck using Struts, but wanted a cleaner,
    POJO-centric component model. <!--todo link to what Spring Web Flow is; assume the n00bs don't know -->Indeed,
    Springs JSF integration for 1.0 and 2.0, as well as the JSF-centric Spring Web
    Flow, offer drastically improved user experiences for developers stuck on those web frameworks. While Struts is
    largely a distant memory, and JSF is fast-becoming one, Spring MVC has emerged as, and remained, the most popular
    Java web framework in the world. </p>

<P> There are a lot of reasons for this, but I think it's because Spring MVC has <EM>embraced</EM> the web, not
    attempted to hide developers from it. Indeed, if Spring MVC can be said to <EM>hide</EM> anything, it is the
    complexities of building scalable Servlet-based applications, <EM>not</EM> the web. </P>

<P> Conceptually, web programming is simple: HTTP requests come in, and responses are created and sent in response. No
    state is retained in between requests on either the server or the client, by default. This can be deceptively
    simple. As requests come in, they invariably are handled by some component that acts on them, and is then charged
    with sending a response. A response, in the common case, is some sort of HTML-based page. Unfortunately, there's
    often a disconnect between effective handling of requests (and tying those requests to the appropriate back-end
    business logic) and rendering of nice responses. Put another way, programmers are rarely good user-interface
    designers. So, a separation of the two domains - business logic and server-side handling from designing and
    rendering rich interactive user interfaces - is often necessary. This way, programmers can work on the part that
    matters most to them - the business logic - and the Adobe Dreamweaver-toting designers can focus on the styling and
    design of the user interface. To keep programming applications that behave in this way simpler, programmers have
    adopted a variant of the popular <span class="wikipedia">MVC</span> pattern called <span id="model2mvc"
                                                                                             class="wikipedia">Model-2 MVC</span>.
    This pattern is best visually described like this: </P>

<div class="diagram"><img src="images/model 2 mvc.png"/> <span class="caption"> The Model-2 MVC pattern </span></div>
<P> As HTTP requests come in, they're routed to the <EM>front controller</EM> - the <span module="spring-web"
                                                                                          class="class-reference">org.springframework.web.servlet.DispatcherServlet</span>
    in Spring MVC - which then selects from among the registered <EM>controller</EM> classes and chooses the right one
    to handle the HTTP request. There needs to be some stipulation between the <EM>front controller</EM> and the
    registered controllers as to which controller should handle which request. When the controller is activated, it is
    given access to all the data about the request and it can react accordingly. Once the request is handled, the
    controller must somehow signal that a response should be rendered. Typically, this means telling the framework which
    <EM>view</EM>, or <EM>response</EM>, to render. A view might be a designer-provided template that merges data into
    itself and then renders as HTML. The response might also be something constructed in code in the controller, like
    file data or the binary data for a PDF or spreadsheet. </P>


<h2>
    Configuring a Servlet 3.0 Container About Our Application</h2>

<p> Working with Spring MVC is <EM>very</EM> straightforward! If you're using a Servlet 3.0 container like the market
    and segment-leading <A href="http://tomcat.apache.org">Apache Tomcat 7</A>, then it's even easier! Our initial Java
    web application consists of three classes - <span module="web" class="class-reference">org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer</span>,
    <span module="web" class="class-reference">org.springsource.examples.spring31.web.config.WebMvcConfiguration</span>,
    and <span module="web" class="class-reference">org.springsource.examples.spring31.web.ViewController</span> - and
    several artifacts to generate the HTML views. Let's look at these classes. </p>

<P>
    <!-- todo rewrite this to reflect -->
    To work with any web framework, like Spring MVC, you need to install the various Servlet components using a
    deployment descriptor (<code>web.xml</code>) or, alternatively, in Servlet 3 environments, a Java initializer class.
    Ours will be a Java Servlet 3.0-compatible web application. Servlet 3.0 applications run in any web container that
    supports Servlet 3.0, including Apache Tomcat 7. You can use Spring in containers that support earlier versions of
    the Servlet specification, however some Servlet 3.0-specific capabilities - such as Java-based initializer classes
    and features designed to support asynchronous responses won't work in those environments. We'll mention the Servlet
    3.0 specific bits as we encounter them. </p>

<P> The Servlet environment provides a few low level class types that can be used in building web applications. Here are
    some of the types of classes that we need to be aware of. </P>
<OL>
    <LI><B>Servlets</B> - objects of type <CODE module="servlets" class="class-reference">javax.servlet.Servlet</code>
        that are given a chance to act on incoming HTTP requests and produce replies. This is the most common type of
        component. <CODE>Servlet</CODE>s are mapped to the URLs that they will respond to by a type of pattern.
    </LI>
    <LI><B>Listener</B> - objects of type <CODE module="servlets" class="class-reference">java.util.EventListener</CODE>
        - typically of a Servlet-speciifc subclass like <CODE module="servlets" class="class-reference">javax.servlet.ServletContextListener</CODE>
        or <CODE module="servlets" class="class-reference">javax.servlet.http.HttpSessionAttributeListener</CODE>. These
        classes are notified of various events in the web application such as the creation of data stored in memory, the
        changes in the Servlet container itself, or changes in one of the Servlets managed by a web application
        container. .
    </LI>
    <LI><B>Filters</B> - objects of type <CODE module="servlets" class="class-reference">javax.servlet.Filter</CODE>
        that are given a chance to act on, or possibly change, incoming HTTP requests before they are routed to the
        <CODE module="servlets" class="class-reference">javax.servlet.Servlet</CODE>s to which they've been routed and
        all outbound HTTP replies produced by those <CODE>Servlets</CODE>. This is useful in many scenarios - such as
        processing security on all requests, or handling things like GZip compression.
    </LI>
</OL>
<P> Unfortunately, the Servlet environment itself is devoid of most of the basics that any modern web application will
    need. Fortunately, Spring provides these building blocks, letting you assemble them as you like, and letting you
    focus on the task at hand: the business of your application. Here is our Java-based application initializer which
    installs Spring's Servlet infrastructure classes to support our application. </P>

<div class="walkthrough">
    <div module="web" class="git-code">
        org.springsource.examples.spring31.web.config.servlet.CrmWebApplicationInitializer
    </div>
    <div><P> The class implements the Spring interface, <span class="class-reference" module="spring-web">org.springframework.web.WebApplicationInitializer</span>.
        which provides a callback method <CODE>void onStartup(ServletContext servletContext) throws
            ServletException</CODE>. This method is called as the application is started by the application container,
        providing a reference to the current <CODE>ServletContext</CODE> which in turn can be used to programmatically
        construct the various Spring MVC framework components.</P>

        <P> This code does two things. It registers a <CODE module="spring-web" class="class-reference">org.springframework.web.context.ContextLoaderListener</code>
            that in turn instantaites our Spring <CODE class="class-reference" module="spring-context">org.springframework.context.ApplicationContext</CODE>
            implementation (<code class="class-reference" module="web">org.springsource.examples.spring31.web.config.WebMvcConfiguration</code>)
            and makes it available to the entire application and all the Servlet components we register. </p>

        <P> Next, we register the <code class="class-reference" module="spring-webmvc">org.springframework.web.servlet.DispatcherServlet</code>.
            This is the class that Spring provides to handle all incoming HTTP requests (the aforementioned <EM>front
                controller</EM>), routing them to the correct <EM>controllers</EM> and working with the other parts of
            the framework to handle common use cases for us. The <CODE>DispatcherServlet</CODE> can manage its own
            <CODE>ApplicationContext</CODE> as well as see and work with the <COde>ApplicationContext</COde> instances
            that the <CODE>ContextLoaderListener</CODE> creates. The <CODE>DispatcherServlet</CODE>'s <CODE>ApplicationContext</CODE>
            is said to be <EM>parented</EM> by the <CODE>ContextLoaderListener</CODE> <CODE>ApplicationContext</CODE>.
            You could, for example, register different <CODE>DispatcherServlet</CODE> instances for different parts of
            the application, and they could share beans in the <EM>parent</EM> <CODE>ApplicationContext</CODE> managed
            by the <CODE>ContextLoaderListener</CODE>. </p>

        <P> As we're running in a Servlet 3 environment, and want to take advanage of <EM>asynchronous</EM> Spring MVC
            controllers, this code activates <EM>async</EM> support on all components where appropriate by calling
            <CODE>setAsync(true)</CODE>. Since we want Spring MVC to have control over the entire application, this code
            <EM>maps</EM> all components to <CODE>/*</CODE> where possible. This means that <EM>all</EM> requests will
            be handled by Spring MVC. We can later specialize our routing from within Spring MVC, of course. </P></div>
</div>
<h2> Configuring our Spring MVC Web Application </h2>

<P> Once we've told the Servlet environment everything it needs to know (for now), we simply need to turn on Spring MVC
    and tailor it based on our application requirements. To get a working, reasonably configured installation of Spring
    MVC, you simply need to add <CODE module="spring-webmvc" class="class-reference">org.springframework.web.servlet.config.annotation.EnableWebMvc</CODE>
    to a Java configuration class that the previously installed <CODE>ContextLoaderListener</CODE> imports.
</p>
<span class="gist" gist="4726096"><script src="https://gist.github.com/joshlong/4726096.js"></script></span>

<P>
    By default,
    this will activate many things based on conventions and the availability of certain libraries on the class path.
    Some of the things supported out of the box: </P>

<uL>
    <LI> The Spring MVC <CODE class="class-reference"
                              module="spring-context">org.springframework.stereotype.Controller</CODE>-annotation based
        component model is turned on. All Spring beans annotated with this stereotype annotation will automatically be
        processed and exported as HTTP handlers. If your application is running in a Servlet 3 environment, then <EM>asynchronous</EM>
        controllers are supported as well.
    </LI>
    <LI> File upload support through the Apache Commons FileUpload library (if detected on the class path) or via the
        Servlet 3 <CODE class="class-reference" module="servlets"> javax.servlet.http.Part </CODE> API.
    </LI>
    <LI><CODE>.jsp</CODE> resource rendering, rendering views at the root of the application.</LI>
    <LI>REST and JSON and XML marshalling support if the Jackson JSON-Object marshalling library or a JAXB
        implementation is on the class path.
    </LI>
    <LI>Bean and form validation if a JSR 303 implementation like Hibernate Validator is on the classpath.</LI>
</uL>
<P> So, while the default configuration gives you a lot out of the box, we will tailor the code a little bit to support
    our application's specific requirements. Most of what we will configure in Spring MVC has to do with customizing how
    Spring MVC renders templates for pages. to understand these use cases better, let's look at the pages and screens we
    know we will need to support. </P>
<TABLE width="600">
    <thead>
    <th> Page</th>
    <th> Preview of Page</th>
    <th> Description</th>
    </thead>
    <tr>
        <td><b> signin</b></td>
        <TD><img width="300" src="images/signin.png"/></TD>
        <td> a page where users can sign in. This should be the home page users are greeted with when they visit the
            application for the first time.
        </td>
    </tr>
    <tr>
        <td><b>signup</b></td>
        <TD><img width="300" src="images/signup.png"/></TD>
        <td> users should be able to sign up for a new account and potentially register via FaceBook</td>
    </tr>
    <!--  <tr>
          <td><b> oops </b></td>
          <TD><img  width="300" src="images/oops.png"/></TD>
          <td> this is the page to show when ever there is an error in the system. Maybe the user accesses the wrong page
              and needs to be given a 404, or perhaps the system throws some sort of awful as-yet-uknown error. Handling
              this gracefully is a sign of polis.
          </td>
      </tr>-->
    <tr>
        <td><b> profile </b></td>
        <TD><img width="300" src="images/profile.png"/></TD>
        <td> there needs to be some place where users can update their profile information like their password and other
            features (like a profile photo?).
        </td>
    </tr>
    <tr>
        <td><b>customers </b></td>
        <TD><img width="300" src="images/customers.png"/></TD>
        <td>there should of course be a screen to work with data related to customers.</td>
    </tr>
</TABLE>
<h1> The Changing Face of the Web </h1>

<P> While individual resources, such as CSS and images and JavaScript are served up the web server, and while initial
    HTML pagses are sent down from the server, much of the interaction that happens between the user and the user
    interface happens these days entirely on the client. The server doesn't really need to get involved too much in
    rendering HTML, besides serving the initial page load and the resources to support it. Nowadays, the client can do a
    <EM>lot</EM> of interesting things, and doesn't need to rely on the server to keep user-interface state. Indeed all
    the server has to do is keep <EM>business</EM> state, and make that available to the client.
    <!-- it does this thorugh REST ... --> </p>

<P> It does through REST, which was introduced by Roy Fielding in his <a href="">2000 doctoral dissertation
    <!--todo link to roy fieldings paper--></a>. </p></body>
</html>